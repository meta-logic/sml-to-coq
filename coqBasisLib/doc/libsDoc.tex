\documentclass[11pt]{report}
\usepackage[]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fullpage}
\usepackage{coqdoc}
\usepackage{amsmath,amssymb}
\usepackage{url}
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% This file has been automatically generated with the command
%% coqdoc --latex notationsSml.v IEEERealSml.v stringCvtSml.v boolSml.v listPairSml.v charSml.v intSml.v listSml.v optionSml.v realSml.v stringSml.v -o output/libsDoc.tex 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\coqlibrary{notationsSml}{Library }{notationsSml}
\section*{notationSml}

\texttt{This file contains all Sml notations implemented in Coq.}



\begin{itemize}
\item  \textbf{ Axiom patternFailure }


\item  \textbf{ Notations for stringSml }

\begin{itemize}
\item  \texttt{= \ : string * string -> bool}

\item  \texttt{<> : string * string -> bool}

\item  \texttt{< \ : string * string -> bool}

\item  \texttt{<= : string * string -> bool}

\item  \texttt{> \ : string * string -> bool}

\item  \texttt{>= : string * string -> bool}

\begin{itemize}
\item \begin{flushleft} \texttt{These functions compare two strings lexicographically, using the underlying ordering on the char type.} \end{flushleft}
\end{itemize}
\coqdocemptyline

\item  \texttt{\^{}  : string * string -> string}

\begin{itemize}
\item  \begin{flushleft} \texttt{s \^{} t : is the concatenation of the strings s and t. This returns Size if |s| + |t| > maxSize.} \end{flushleft}
\end{itemize}

\end{itemize}


\item  \textbf{Notations for charSml}



\begin{itemize}
\item  \texttt{= \ : ascii * ascii -> bool}

\item  \texttt{<> : ascii * ascii -> bool}

\item  \texttt{< \ : ascii * ascii -> bool}

\item  \texttt{<= : ascii * ascii -> bool}

\item  \texttt{> \ : ascii * ascii -> bool}

\item \begin{flushleft} \texttt{>= : ascii * ascii -> bool} \end{flushleft}

\begin{itemize}
\item  \texttt{These compare characters in the character ordering.}
\end{itemize}

\end{itemize}
\newpage

\item \textbf{Notations for intSml}

\begin{itemize}
\item  \texttt{= \ : Z * Z -> bool}

\item  \texttt{<> : Z * Z -> bool}

\item  \texttt{< \ : Z * Z -> bool}

\item  \texttt{<= : Z * Z -> bool}

\item  \texttt{> \ : Z * Z -> bool}

\item  \texttt{>= : Z * Z -> bool}

\begin{itemize}
\item \begin{flushleft} \texttt{These return true if the corresponding relation holds between the two integers.} \end{flushleft}
\end{itemize}
\coqdocemptyline

\item  \texttt{+ \ \ : Z * Z -> Z}

\item  \texttt{- \ \ : Z * Z -> Z}

\item  \texttt{* \ \ : Z * Z -> Z}

\item  \texttt{div : Z * Z -> Z}

\item  \texttt{mod : Z * Z -> Z}

\item  \texttt{rem : Z * Z -> Z}

\begin{itemize}
\item  \begin{flushleft} \texttt{These functions return the sum, difference, and product, respectively, of the arguments.} \end{flushleft}
\end{itemize}
\coqdocemptyline

\item  \texttt{Definition abs : Z -> Z}

\begin{itemize}
\item  \texttt{abs i : returns the absolute value (magnitude) of i.}



\end{itemize}

\end{itemize}

\item  \textbf{Notations for realSml}

\begin{itemize}
\item  \texttt{< \ : float * float -> bool}

\item  \texttt{<= : float * float -> bool}

\item  \texttt{> \ : float * float -> bool}

\item  \texttt{>= : float * float -> bool}

\begin{itemize}
\item \begin{flushleft} \texttt{These return true if the corresponding relation holds between the two reals.} \end{flushleft}
\coqdocemptyline


\end{itemize}

\item  \texttt{== : float * float -> bool}

\item  \texttt{!= : float * float -> bool}

\begin{itemize}
\item \begin{flushleft} \texttt{The first returns true if and only if neither y nor x is NaN, and y and x are equal, ignoring signs on zeros. The second function != is equivalent to not o op ==.} \end{flushleft}
\coqdocemptyline


\end{itemize}

\item  \texttt{?= : float * float -> bool}

\begin{itemize}
\item \begin{flushleft} \texttt{This returns true if either argument is NaN or if the arguments are bitwise equal, ignoring signs on zeros.} \end{flushleft}
\newpage


\end{itemize}

\item  \texttt{+ : float * float -> float}

\item  \texttt{- : float * float -> float}

\begin{itemize}
\item \texttt{r1 + r2} 
\item \texttt{r1 - r2}

\begin{itemize}
\item \begin{flushleft} \texttt{These denote the sum and difference of r1 and r2. If one argument is finite and the other infinite, the result is infinite with the correct sign, e.g., 5 - (-infinity) = infinity. We also have infinity + infinity = infinity and (-infinity) + (-infinity) = (-infinity). Any other combination of two infinities produces NaN.} \end{flushleft}
\end{itemize}

\end{itemize}
\coqdocemptyline
\coqdocemptyline

\item  \texttt{* : float * float -> float}

\begin{itemize}
\item  \begin{flushleft} \texttt{These denote the sum and difference of r1 and r2. If one argument is finite and the other infinite, the result is infinite with the correct sign, e.g., 5 - (-infinity) = infinity. We also have infinity + infinity = infinity and (-infinity) + (-infinity) = (-infinity). Any other combination of two infinities produces NaN.} \end{flushleft}
\end{itemize}
\coqdocemptyline
\coqdocemptyline

\item  \texttt{/ : float * float -> float}

\begin{itemize}
\item   \begin{flushleft} \texttt{r1 / r2 : denotes the quotient of r1 and r2. We have 0 / 0 = NaN and +-infinity / +-infinity = NaN. Dividing a finite, non-zero number by a zero, or an infinity by a finite number produces an infinity with the correct sign. (Note that zeros are signed.) A finite number divided by an infinity is 0 with the correct sign.} \end{flushleft}
\end{itemize}
\coqdocemptyline
\coqdocemptyline

\item  \texttt{*+ : float * float * float -> float}

\item  \texttt{*- : float * float * float -> float}

\begin{itemize}
\item \texttt{*+(a, b, c)} 
\item \texttt{*-(a, b, c)}

\begin{itemize}
\item \begin{flushleft} \texttt{These return a*b + c and a*b - c, respectively. Their behaviors on infinities follow from the behaviors derived from addition, subtraction, and multiplication.} \end{flushleft}
\end{itemize}

\end{itemize}
\coqdocemptyline
\coqdocemptyline

\item \texttt{Definition abs : float -> float}

\begin{itemize}
\item  \texttt{abs r : returns the absolute value |r| of r.}

\begin{itemize}
\item  \begin{flushleft}\texttt{abs (+-0.0) = +0.0 , abs (+-infinity) = +infinity , abs (+-NaN) = +NaN} \end{flushleft}
\end{itemize}

\end{itemize}

\end{itemize}
\coqdocemptyline
\coqdocemptyline

\item  \textbf{Notations for boolSml}

\begin{itemize}
\item \texttt{= \ : bool * bool -> bool}

\item  \texttt{<> : bool * bool -> bool}

\begin{itemize}
\item \begin{flushleft} \texttt{These return true if the corresponding relation holds between the two boolean values.} \end{flushleft}

\end{itemize}

\end{itemize}

\item \textbf{ Notations for listSml}

\begin{itemize}
\item  \texttt{ @ : list A * list A -> list A}

\begin{itemize}
\item  \texttt{l1 @ l2 : returns the list that is the concatenation of l1 and l2.}

\end{itemize}

\end{itemize}

\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{IEEERealSml}{Library }{IEEERealSml}
\section*{IEEERealSml}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\texttt{ \coqdockw{Module} \coqdocvar{IEEEReal}.\coqdoceol}
\coqdocemptyline
\end{coqdoccode}

\begin{itemize}
\item  \texttt{Axiom UnorderedException}



\item  \texttt{Inductive real\_order := LESS | EQUAL | GREATER | UNORDERED.}



\item \texttt{ Inductive float\_class := 
        NAN
      | INF
      | ZERO
      | NORMAL
      | SUBNORMAL. }



\item \texttt{ Inductive float\_class := 
      | NAN
      | INF
      | ZERO
      | NORMAL
      | SUBNORMAL.}



\item  \texttt{ Definition setRoundingMode : Not Implemented.}



\item  \texttt{ Definition getRoundingMode : Not Implemented.}



\item  \texttt{ Record decimal\_approx :=\\ \{
                                class : float\_class;
                                sign : bool;
                                digits : list Z;
                                exp : Z
                              \}.}

\begin{itemize}
\item  \begin{flushleft} \texttt{ 
This type provides a structured decimal representation of a real. The class field indicates the real class. If sign is true, the number is negative. The integers in the digits list must be digits, i.e., between 0 and 9.\\
When class is NORMAL or SUBNORMAL, a value of type decimal\_approx with 
digits = $[d_1, d_2, ..., d_n]$ corresponds to the real number $s * 0.d_1 d_2 ... d_n \ 10^{exp}$, where s is -1 if sign is true and 1 otherwise. When class is ZERO or INF, the value corresponds to zero or infinity, respectively, with its sign determined by sign. When class is NAN, the value corresponds to an unspecified nan value. } \end{flushleft} 



\end{itemize}

\item \texttt{Definition toString : decimal\_approx -> string}

\begin{itemize}
\item  \begin{flushleft} \texttt{toString d : returns a string representation of d. Assuming digits = $d_1, d_2, ..., d_n$ and ignoring the sign and exp fields, toString generates the following strings depending on the class field: ZERO => "0.0", NORMAL =>	"$0.d_1 d_2 d_n$", SUBNORMAL =>	"$0.d_1 d_2 d_n$", INF => "inf", NAN =>	"nan". } \end{flushleft}


\end{itemize}

\item \texttt{Definition scan : Not Implemented.}



\item \texttt{Definition fromString : string -> option decimal\_approx}

\begin{itemize}
\item \begin{flushleft} \texttt{ It returns the decimal approximation on success and NONE otherwise. The fromString function is equivalent to StringCvt.scanString scan.\\
\coqdocemptyline
The functions accept real numbers with the following format:}\\
\begin{itemize}
\item $[+ \textasciitilde{} -]^?([0-9]^+.[0-9]^+? | .[0-9]^+)(e|E)[+ \textasciitilde{} -]^?[0-9]^+$
\end{itemize}
 
\texttt{The optional sign determines the value of the sign field, with a default of false. Initial zeros are stripped from the integer part and trailing zeros are stripped from the fractional part, yielding two lists il and fl, respectively, of digits. If il is non-empty, then class is set to NORMAL,digits is set to il@fl with any trailing zeros removed and exp is set to the length of il plus the value of the scanned exponent, if any. If il is empty and so is fl, then class is set to ZERO, digits = [] and exp = 0. Finally, if il is empty but fl is not, let m be the number of leading zeros in fl and let fl' be fl after the leading zeros are removed. Then, class is set to NORMAL, digits is set to fl' and exp is set to -m plus the value of the scanned exponent, if any.\\
\coqdocemptyline
They also accept the following string representations of non-finite values:}

\begin{itemize}
\item $[+ \textasciitilde{} -]^?(\text{inf | infinity | nan})$
\end{itemize}

\texttt{where the alphabetic characters are case-insensitive. The optional sign determines the value of the sign field, with a default of false. In the first and second cases, d will have class set to INF. In the third case, class is set to NAN. In all these cases, d will have digits = [] and exp = 0. } \end{flushleft}

\end{itemize}

\end{itemize}




\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\texttt{\coqdockw{End} \coqdocvar{IEEEReal}.\coqdoceol}
\end{coqdoccode}
\coqlibrary{stringCvtSml}{Library }{stringCvtSml}
\section*{stringCvtSml}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\texttt{\coqdockw{Module} \coqdocvar{StringCvt}.\coqdoceol}
\coqdocemptyline
\end{coqdoccode}



\begin{itemize}
\item  \texttt{Inductive radix := BIN | OCT | DEC | HEX.}

\begin{itemize}
\item  \texttt{The values of type radix are used to specify the radix of a representation of an integer, corresponding to the bases 2, 8, 10, and 16, respectively.}
\end{itemize}

\item  \texttt{Inductive realfmt :=\\| SCI (i : option Z)\\ | FIX (i : option Z)\\ | GEN (i : option Z)\\ | EXACT.}

\begin{itemize}

\item  \begin{flushleft} \texttt{Values of type realfmt are used to specify the format of a string representation for a real or floating-point number.\\ 
\coqdocemptyline
The first corresponds to scientific representation:}

\begin{itemize}
\item $[ \textasciitilde{} ]^?[0-9].[0-9]^{+?}\text{E}[0-9]^+$
\end{itemize}

\texttt{ where there is always one digit before the decimal point, nonzero if the number is nonzero. The optional integer value specifies the number of decimal digits to appear after the decimal point, with 6 being the default.In particular, if 0 is specified, there should be no fractional part.The exponent is zero if the value is zero.\\
\coqdocemptyline
The second corresponds to a fixed-point representation:}
\begin{itemize}
\item $[ \textasciitilde{} ]^?[0-9].[0-9]^{+?}$
\end{itemize}

\texttt{where there is always at least one digit before the decimal point. The optional integer value specifies the number of decimal digits to appear after the decimal point, with 6 being the default. In particular, if 0 is specified, there should be no fractional part.\\
\coqdocemptyline
The third constructor GEN allows a formatting function to use either the scientific or fixed-point notation, whichever is shorter, breaking ties in favor of fixed-point. The optional integer value specifies the maximum number of significant digits used, with 12 the default. The string should display as many significant digits as possible, subject to this maximum. There should not be any trailing zeros after the decimal point. There should not be a decimal point unless a fractional part is included. \\
\coqdocemptyline
\coqdocvar{FLOAT} provides a reference implementation for this conversion.\\
\coqdocemptyline
The fourth constructor EXACT specifies that the string should represent the real using an exact decimal representation. The string contains enough information in order to reconstruct a semantically equivalent real value using REAL.fromDecimal o valOf o IEEEReal.fromString. Refer to the description of IEEEReal.toString for more precise information concerning this format.\\
\coqdocemptyline
In all cases, positive and negative infinities are converted to "inf" and "-inf", respectively, and nan values are converted to the string "nan".} \end{flushleft}

\end{itemize}

\item  \texttt{Definition reader A B := B -> option (A * B).}

\begin{itemize}
\item  The type of a reader producing values of type A from a stream of type B. A return value of Some(a,b) corresponds to a value a scanned from the stream, plus the remainder b of the stream. A return value of None indicates that no value of the correct type could be scanned from the prefix of the stream.\\
\coqdocemptyline
The reader type is designed for use with a stream or functional view of I/O. Scanning functions using the reader type, such as skipWS, splitl, and Int.scan, will often use lookahead characters to determine when to stop scanning. If the character source (B in an reader A B) is imperative, the lookahead characters will be lost to any subsequent scanning of the source. One mechanism for combining imperative I/O with the standard scanning functions is provided by the TextIO.scanStream function. 
\end{itemize}

\item \texttt{Definition padLeft : ascii -> Z -> string -> string}

\item  \texttt{Definition padRight : ascii -> Z -> string -> string}

\begin{itemize}
\item   padLeft c i s 
\item padRight c i s 
\begin{itemize}
\item These return s padded, on the left or right, respectively, with i - |s| copies of the character c. If |s| >= i, they just return the string s. In other words, these functions right and left-justify s in a field i characters wide, never trimming off any part of s. Note that if i <= 0, s is returned. These functions return the axiom String.SizeException if the size of the resulting string would be greater than String.maxSize.
\end{itemize}

\end{itemize}

\item  \texttt{Definition splitl : (ascii -> bool) -> reader ascii A -> A -> nat -> string * A}

\begin{itemize}
\item  \begin{flushleft} \texttt{splitl f rdr src time : returns (pref, src') where pref is the longest prefix (left substring) of src, as produced by the character reader rdr, all of whose characters satisfy f, and src' is the remainder of src. Thus, the first character retrievable from src' is the leftmost character not satisfying f.\\
\coqdocemptyline
splitl can be used with scanning functions such as scanString by composing it with Some; e.g., scanString (fn rdr => SOME o (splitl f rdr time)).\\
\coqdocemptyline
The parameter time is an upper-bound of the number of the required iteration for splitl that the user should provide splitl with. i.e, if A is string then time would be length(src).} \end{flushleft}



\end{itemize}

\item  \texttt{Definition takel : (ascii -> bool) -> reader ascii A -> A -> nat -> string}

\item  \texttt{Definition dropl : (ascii -> bool) -> reader ascii A -> A -> nat -> A}

\begin{itemize}
\item  \begin{flushleft}  \texttt{takel f rdr src time | dropl f rdr src time : These routines scan the source src for the first character not satisfying the predicate f. The function dropl drops the maximal prefix consisting of characters satisfying the predicate, returning the rest of the source, while takel returns the maximal prefix consisting of characters satisfying the predicate.\\
\coqdocemptyline
The parameter time is an upper-bound of the number of the required iteration for splitl that the user should provide splitl with. i.e, if A is string then time would be length(src).} \end{flushleft}
\end{itemize}

\item  \texttt{Definition skipWS : reader ascii A -> A -> nat -> A}

\begin{itemize}
\item  \begin{flushleft} \texttt{skipWS rdr src time : strips whitespace characters from a stream src using the reader rdr. It returns the remaining stream. A whitespace character is one that satisfies the predicate Char.isSpace. It is equivalent to dropl Char.isSpace.\\
\coqdocemptyline
The parameter time is an upper-bound of the number of the required iteration for splitl that the user should provide splitl with. i.e, if A is string then time would be length(src).} \end{flushleft}



\end{itemize}

\item  \texttt{Definition cs}

\begin{itemize}
\item  \texttt{The abstract type of the character stream used by scanString. A value of this type represents the state of a character stream. The concrete type is left unspecified to allow implementations a choice of representations. Typically, cs will be an Z index into a string.}



\end{itemize}

\item  \texttt{Definition scanString : (reader ascii cs -> reader A cs) -> string -> option A}

\begin{itemize}
\item  \texttt{The function scanString provides a general framework for converting a string into some value. The user supplies a scanning function and a string.scanString converts the string into a character source (type cs) and applies the scanning function. A scanning function converts a reader of characters into a reader of values of the desired type. Typical scanning functions are Bool.scan and Date.scan. }

\end{itemize}

\end{itemize}
\begin{coqdoccode}
\coqdocnoindent
\texttt{\coqdockw{End} \coqdocvar{StringCvt}.\coqdoceol}
\end{coqdoccode}
\coqlibrary{boolSml}{Library }{boolSml}
\section*{boolSml}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\texttt{\coqdockw{Module} \coqdocvar{Bool}.\coqdoceol}
\coqdocemptyline
\end{coqdoccode}

\begin{itemize}
\item  \texttt{Defintion not : bool -> bool}


\begin{itemize}
\item  \texttt{not b : returns the logical negation of the boolean value b.}
\end{itemize}

\item  \texttt{Defintion toString : bool -> string}

\begin{itemize}
\item  \texttt{toString b: returns the string representation of b, either "true" or "false".}
\end{itemize}

\item  \texttt{Defintion scan : Not Implemented.}

\item  \texttt{Defintion fromString : string -> bool option}

\begin{itemize}
\item  \texttt{fromString s:scans a boolean from a string s.It returns SOME(b) for a scanned value b; otherwise it returns None.The function fromString is equivalent to StringCvt.scanString scan.} 
\end{itemize}

\end{itemize}


\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\texttt{\coqdockw{End} \coqdocvar{Bool}.\coqdoceol}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{listPairSml}{Library }{listPairSml}
\section*{listPairSml}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\texttt{\coqdockw{Module} \coqdocvar{ListPair}.\coqdoceol}
\coqdocemptyline
\end{coqdoccode}

\begin{itemize}
\item  \texttt{Axiom  UnequalLengthsException}

\item  \texttt{Definition zip : list A * list A -> list (A * B)}

\item  \texttt{Definition zipEq : list A * list A -> list (A * B)}

\begin{itemize}
\item \texttt{zip (l1, l2)} 
\item \texttt{zipEq (l1, l2)}

\begin{itemize}
\item \begin{flushleft} \texttt{These functions combine the two lists l1 and l2 into a list of pairs, with the first element of each list comprising the first element of the result, the second elements comprising the second element of the result, and so on. If the lists are of unequal lengths, zip ignores the excess elements from the tail of the longer one, while zipEq returns the axiom UnequalLengthsException.} \end{flushleft}
\end{itemize}

\end{itemize}

\item  \texttt{Definition unzip : list (A * B) -> list A * list B}

\begin{itemize}
\item  \texttt{ unzip l : returns a pair of lists formed by splitting the elements of l. This is the inverse of zip for equal length lists.}



\end{itemize}

\item  \texttt{Definition app : (A * B -> unit) -> list A * list B -> unit}

\item  \texttt{Definition appEq : (A * B -> unit) -> list A * list B -> unit}

\begin{itemize} 
\item \texttt{app f (l1, l2)} 
\item \texttt{appEq f (l1, l2)} 

\begin{itemize}

\item \begin{flushleft} \texttt{These apply the function f to the list of pairs of elements generated from left to right from the lists l1 and l2. If the lists are of unequal lengths, the former ignores the excess elements from the tail of the longer one, and the latter returns the axiom UnequalLengthsException. The above expressions are respectively equivalent to:} \end{flushleft}

\begin{itemize}
\item  \texttt{List.app f (zip (l1, l2))}
\item  \texttt{List.app f (zipEq (l1, l2))}
\end{itemize}

\end{itemize}
\end{itemize}

\item \texttt{Definition map : (A * B -> C) -> list A * list B -> list C}

\item  \texttt{Definition mapEq : (A * B -> C) -> list A * list B -> list C}

\begin{itemize}
\item \texttt{map f (l1, l2)} 
\item \texttt{mapEq f (l1, l2)} 

\begin{itemize}
\item \begin{flushleft} \texttt{These map the function f over the list of pairs of elements generated from left to right from the lists l1 and l2, returning the list of results. If the lists are of unequal lengths, the former ignores the excess elements from the tail of the longer one, and the latter returns the axiom UnequalLengthsException. The above expressions are respectively equivalent to:} \end{flushleft}

\begin{itemize}
\item  \texttt{List.map f (zip (l1, l2))}
\item  \texttt{List.map f (zipEq (l1, l2))}
\end{itemize}

\end{itemize}

\end{itemize}

\item  \texttt{Definition foldl : (A * B * C -> C) -> C -> list A * list B -> C}

\item  \texttt{Definition foldr : (A * B * C -> C) -> C -> list A * list B -> C}

\item  \texttt{Definition foldlEq : (A * B * C -> C) -> C -> list A * list B -> C}

\item  \texttt{Definition foldrEq : (A * B * C -> C) -> C -> list A * list B -> C}

\begin{itemize}
\item \texttt{foldl f init (l1, l2)} 
\item \texttt{foldr f init (l1, l2)} 
\item \texttt{foldlEq f init (l1, l2)} 
\item \texttt{foldrEq f init (l1, l2)} 

\begin{itemize} 
\item  \begin{flushleft} \texttt{These return the result of folding the function f in the specified direction over the pair of lists l1 and l2 starting with the value init. They are respectively equivalent to:} \end{flushleft}

\begin{itemize}
\item  \texttt{List.foldl f' init (zip (l1, l2))}
\item  \texttt{List.foldr f' init (zip (l1, l2))}
\item  \texttt{List.foldl f' init (zipEq (l1, l2))}
\item  \texttt{List.foldr f' init (zipEq (l1, l2))}
\end{itemize}
\texttt{where f' is fn ((a,b),c) => f(a,b,c) and ignoring possible side-effects of the function f.}

\end{itemize}

\end{itemize}

\item  \texttt{Definition all : (A * B -> bool) -> list A * list B -> bool}

\item  \texttt{Definition existsb : (A * B -> bool) -> list A * list B -> bool}

\begin{itemize}
\item \texttt{all f (l1, l2)}
\item \texttt{exists f (l1, l2)}

\begin{itemize}
\item \begin{flushleft} \texttt{These functions provide short-circuit testing of a predicate over a pair of lists. They are respectively equivalent to:} \end{flushleft}

\begin{itemize}
\item  \texttt{List.all f (zip (l1, l2))}
\item  \texttt{List.existsb f (zip (l1, l2))}
\end{itemize}

\end{itemize}

\end{itemize}

\item  \texttt{Definition allEq : A * B -> bool) -> list A * list B -> bool}

\begin{itemize}
\item  \begin{flushleft} texttt{allEq f (l1, l2) : returns true if l1 and l2 have equal length and all pairs of elements satisfy the predicate f. That is, the expression is equivalent to:} \end{flushleft}

\begin{itemize}
\item  \texttt{(List.length l1 = List.length l2) \&\& (List.all f (zip (l1, l2)))}

\end{itemize}

\end{itemize}

\end{itemize}


\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\texttt{\coqdockw{End} \coqdocvar{ListPair}.\coqdoceol}
\end{coqdoccode}
\coqlibrary{charSml}{Library }{charSml}
\section*{charSml}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\texttt{\coqdockw{Module} \coqdocvar{Char}.\coqdoceol}
\coqdocemptyline
\end{coqdoccode}



\begin{itemize}
\item  \texttt{Axiom ChrException}



\item  \texttt{Definition minChar : ascii}

\begin{itemize}
\item  \texttt{The least character in the ordering. It always equals chr 0.}
\end{itemize}

\item  \texttt{Definition maxChar : ascii}

\begin{itemize}
\item  \texttt{The greatest character in the ordering; it equals chr maxOrd.}
\end{itemize}

\item  \texttt{Definition maxOrd : ascii}

\begin{itemize}
\item  \texttt{The greatest character code; it equals ord maxChar.}



\end{itemize}

\item \texttt{Definition ord : ascii -> Z}

\begin{itemize}
\item  \texttt{ord c : returns the (non-negative) integer code of the character c.}
\end{itemize}

\item  \texttt{Definition chr : Z -> ascii}

\begin{itemize}
\item  \begin{flushleft} \texttt{chr i : returns the character whose code is i; returns the axiom ChrException if i < 0 or i > maxOrd.}\end{flushleft}



\end{itemize}

\item  \texttt{Definition succ : ascii -> ascii}

\begin{itemize}
\item  \begin{flushleft}\texttt{succ c : returns the character immediately following c in the ordering, or returns the axiom ChrException if c = maxChar. When defined, succ c is equivalent to chr(ord c + 1).}\end{flushleft}
\end{itemize}

\item  \texttt{Definition pred : ascii -> ascii}

\begin{itemize}
\item \begin{flushleft} \texttt{pred c :returns the character immediately preceding c, or returns the axiom ChrException if c = minChar. When defined, pred c is equivalent to chr(ord c - 1).} \end{flushleft}
\end{itemize}

\item  \texttt{Definition compare : ascii * ascii -> comparison}

\begin{itemize}
\item  \begin{flushleft} \texttt{compare (c, d) : returns Lt, Eq, or Gt, depending on whether c precedes, equals, or follows d in the character ordering.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition contains : string -> ascii -> bool}

\begin{itemize}
\item \begin{flushleft} \texttt{contains s c : returns true if character c occurs in the string s; otherwise it returns false.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition notContains : string -> ascii -> bool}

\begin{itemize}
\item  \begin{flushleft} \texttt{notContains s c : returns true if character c does not occur in the string s; it returns false otherwise. It is equivalent to not(contains s c).} \end{flushleft}
\end{itemize}

\item  \texttt{Definition isAscii : ascii -> bool}

\begin{itemize}
\item  \begin{flushleft} \texttt{isAscii c : returns true if c is a (seven-bit) ASCII character, i.e., 0 <= ord c <= 127. Note that this function is independent of locale.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition toLower : ascii -> ascii}

\item  \texttt{Definition toUpper : ascii -> ascii}

\begin{itemize}
\item  \texttt{toLower c}
\item  \texttt{toUpper c}
\begin{itemize}
\item \begin{flushleft} \texttt{These return the lowercase (respectively, uppercase) letter corresponding to c if c is a letter; otherwise it returns c.} \end{flushleft}
\end{itemize}

\end{itemize}

\item  \texttt{Definition isAlpha : ascii -> bool}

\begin{itemize}
\item  \texttt{isAlpha c :  returns true if c is a letter (lowercase or uppercase).}



\end{itemize}

\item  \texttt{Definition isAlphaNum : ascii -> bool}

\begin{itemize}
\item  \begin{flushleft} \texttt{isAlphaNum c :  returns true if c is alphanumeric (a letter or a decimal digit).} \end{flushleft}
\end{itemize}

\item  \texttt{Definition inCntrl : asscii -> bool}

\begin{itemize}
\item  \texttt{isCntrl c :  returns true if c is a control character.}
\end{itemize}

\item  \texttt{Definition isDigit : ascii -> bool}

\begin{itemize}
\item \texttt{isDigit c :  returns true if c is a decimal digit 0-9.}
\end{itemize}

\item  \texttt{Definition isGraph : ascii -> bool}

\begin{itemize}
\item  \begin{flushleft} \texttt{isGraph c :  returns true if c is a graphical character, that is, it is printable and not a whitespace character.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition isHexDigit : ascii -> bool}

\begin{itemize}
\item  \begin{flushleft} \texttt{isHexDigit c :  returns true if c is a hexadecimal digit [0-9 \coqdocvar{a}-\coqdocvar{f A}-\coqdocvar{F}].} \end{flushleft}



\end{itemize}

\item  \texttt{Definition isLower : ascii -> bool}

\begin{itemize}
\item  \texttt{isLower c :  returns true if c is a lowercase letter.}
\end{itemize}

\item  \texttt{Definition isPrint : ascii -> bool}

\begin{itemize}
\item  \begin{flushleft} \texttt{isPrint c :  returns true if c is a printable character (space or visible), i.e., not a control character.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition isSpace : ascii -> bool}

\begin{itemize}
\item  \begin{flushleft} \texttt{isSpace c : returns true if c is a whitespace character (space, newline, tab, carriage return, vertical tab, formfeed).} \end{flushleft}
\end{itemize}

\item  \texttt{Definition isPunct : ascii -> bool}

\begin{itemize}
\item  \begin{flushleft} \texttt{isPunct c : returns true if c is a punctuation character: graphical but not alphanumeric.} \end{flushleft}
\end{itemize}

\item  Definition isUpper : ascii -> bool

\begin{itemize}
\item  \texttt{isUpper c :  returns true if c is an uppercase letter.}
\end{itemize}

\item  \texttt{Definition toString : ascii -> string}

\begin{itemize}
\item  \texttt{toString c : returns a printable string representation of the character.} 
\end{itemize}

\item  \texttt{Definition toCsString : ascii -> string}

\begin{itemize}
\item  \begin{flushleft} \texttt{toCsString c : returns a printable string corresponding to c, with non-printable characters replaced by C escape sequences.} \end{flushleft}
\end{itemize}

\item \texttt{Definition fromString : string -> option ascii}

\begin{itemize}
\item  \begin{flushleft} \texttt{fromString c : scan a character (including possibly a space) or an Coq escape sequence representing a character from the prefix of a character stream or a string of printable characters, as allowed in an Coq program.} \end{flushleft}
\end{itemize}

\item \texttt{Definition fromCString : string -> option ascii}

\begin{itemize}
\item  \begin{flushleft} \texttt{fromCString c : scans a character (including possibly a space) or a C escape sequence representing a character from the prefix of a string. After a successful conversion, fromCString ignores any additional characters in s.} \end{flushleft}
\end{itemize}

\end{itemize}






\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\texttt{\coqdockw{End} \coqdocvar{Char}.\coqdoceol}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{intSml}{Library }{intSml}
\section*{intSml}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\texttt{\coqdockw{Module} \coqdocvar{Int}.\coqdoceol}
\coqdocemptyline
\end{coqdoccode}



\begin{itemize}
\item  \texttt{Definition toLarge \ \  : Z -> Z}

\item  \texttt{Definition fromLarge : Z -> Z}

\item  \texttt{Definition toInt \ \ \ \ : Z -> Z}

\item  \texttt{Definition fromInt \ \ : Z -> Z}

\begin{itemize}
\item  \texttt{toLarge i}
\item  \texttt{fromLarge i}
\item  \texttt{toInt i}
\item  \texttt{fromInt i}

\begin{itemize}
\item  \texttt{returns i.}
\end{itemize}

\end{itemize}

\item  \texttt{Definition precision : option Z}

\begin{itemize}
\item  \begin{flushleft} \texttt{If Some(n), this denotes the number n of significant bits in type Z, including the sign bit. If it is None, Z has arbitrary precision. The precision need not necessarily be a power of two. } \end{flushleft}
\end{itemize}

\item  \texttt{Definition minInt : option Z}

\item  \texttt{Definition maxInt : option Z}

\begin{itemize}
\item \begin{flushleft} \texttt{The minimal (most negative) and the maximal (most positive) integers, respectively, representable by Z. If a value is None, Z can represent all negative (respectively, positive) integers, within the limits of the heap size.\\
If precision is Some(n), then we have minInt = $-2^{(n-1)}$ and maxInt = $2^{(n-1)} - 1$.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition quot : Z * Z -> Z}

\begin{itemize}
\item \begin{flushleft} \texttt{quot (i, j) : returns the truncated quotient of the division of i by j, i.e., it computes (i / j) and then drops any fractional part of the quotient. It rounds towards zero.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition compare : Z * Z -> comparison}

\begin{itemize}
\item  \begin{flushleft} \texttt{compare (i ,j): returns Lt, Eq, or Gt when i is less than, equal to, or greater than j, respectively.} \end{flushleft}

\end{itemize}

\item  \texttt{Definition abs : Z -> Z}

\begin{itemize}
\item  \texttt{abs i : returns the absolute value (magnitude) of i.}



\end{itemize}

\item  \texttt{Definition min : Z * Z -> Z}

\item  \texttt{Definition max : Z * Z -> Z}

\begin{itemize}
\item   \texttt{These return the smaller (respectively, larger) of the arguments.}



\end{itemize}

\item  \texttt{Definition sign : Z -> Z}

\begin{itemize}
\item  \begin{flushleft} \texttt{sign i : returns -1, 0, or 1 when i is less than, equal to, or greater than 0, respectively.} \end{flushleft}

\end{itemize}

\item  \texttt{Definition sameSign : Z * Z -> bool}

\begin{itemize}
\item  \begin{flushleft} \texttt{sameSign (i, j) :  returns true if i and j have the same sign. It is equivalent to (sign i = sign j).} \end{flushleft}

\end{itemize}

\item  \texttt{Definition fmt : StringCvt.radix -> Z -> string}

\item  \texttt{Definition toString : Z -> string}

\begin{itemize}
\item  \texttt{fmt radix i}

\item  \texttt{toString i}

\begin{itemize}
\item  \texttt{These return a string containing a representation of i with "A" through. }
\end{itemize}

\end{itemize}

\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\texttt{\coqdockw{End} \coqdocvar{Int}.\coqdoceol}
\end{coqdoccode}
\coqlibrary{listSml}{Library }{listSml}
\section*{listSml}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\texttt{\coqdockw{Module} \coqdocvar{List}.\coqdoceol}
\coqdocemptyline
\end{coqdoccode}

\begin{itemize}
\item  \texttt{Axiom  EmptyException}



\item  \texttt{Axiom  SubscriptException}



\item  \texttt{Axiom SizeException}



\item  \texttt{Definition null : list A -> bool}

\begin{itemize}
\item  \texttt{null l : returns true if the list l is empty.}



\end{itemize}

\item  \texttt{Definition length l : list A -> Z}

\begin{itemize}
\item  \texttt{length l : returns the number of elements in the list l.}
\end{itemize}

\item  \texttt{Definition hd : list A -> A}

\begin{itemize}
\item \begin{flushleft} \texttt{hd l : returns the first element of l. It returns the axiom EmptyException if l is nil.} \end{flushleft}



\end{itemize}

\item \texttt{ Definition tl : list A -> list A}

\begin{itemize}
\item \begin{flushleft} \texttt{ tl l : returns all but the first element of l. It returns the axiom EmptyException  if l is nil.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition last : list A -> }A

\begin{itemize}
\item  \begin{flushleft} \texttt{ last l : returns the last element of l. It returns the axiom EmptyException if l is nil.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition getItem : list A -> option (A * list A)}

\begin{itemize}
\item  \begin{flushleft} \texttt{getItem l : returns None if the list is empty, and Some(hd l,tl l) otherwise. This function is particularly useful for creating value readers from lists of characters. For example, Int.scan StringCvt.DEC getItem has the type StringCvt.reader Z (list Z) and can be used to scan decimal integers from lists of characters. } \end{flushleft}



\end{itemize}

\item  \texttt{Definition nth : list A * Z -> A}

\begin{itemize}
\item  \begin{flushleft} \texttt{nth (l, i) : returns the i(th) element of the list l, counting from 0. It returns the axiom SubscriptException if i < 0 or i >= length l. We have nth(l,0) = hd l, ignoring exceptions. } \end{flushleft}



\end{itemize}

\item  \texttt{Definition take : list A * Z -> list A}

\begin{itemize}
\item  \begin{flushleft} \texttt{take (l, i) : returns the first i elements of the list l. It returns the axiom SubscriptException if i < 0 or i > length l. We have take(l, length l) = l.} \end{flushleft}



\end{itemize}

\item  \texttt{Definition drop : list A * Z -> list A}

\begin{itemize}
\item \begin{flushleft} \texttt{ drop (l, i) : returns what is left after dropping the first i elements of the list l. It returns the axiom SubscriptException if i < 0 or i > length l. It holds that take(l, i) @ drop(l, i) = l when 0 <= i <= length l. We also have drop(l, length l) = []. } \end{flushleft}



\end{itemize}

\item  \texttt{Definition rev : list A -> list A}

\begin{itemize}
\item  \texttt{rev l : returns a list consisting of l's elements in reverse order.}



\end{itemize}

\item  \texttt{Definition concat : list(list A) -> list A}

\begin{itemize}
\item  \begin{flushleft} \texttt{concat l : returns the list that is the concatenation of all the lists in l in order.} \end{flushleft}

\begin{itemize}
\item  \texttt{concat[\coqdocvar{l1},\coqdocvar{l2},...\coqdocvar{ln}] = l1 @ l2 @ ... @ ln}
\end{itemize}

\end{itemize}

\item  \texttt{Definition revAppend : list A * list A -> list A}

\begin{itemize}
\item  \texttt{revAppend (l1, l2) :  returns (rev l1) @ l2.}
\end{itemize}

\item  \texttt{Definition app : (A -> unit) -> list A -> unit}

\begin{itemize}
\item  \texttt{app f l : applies f to the elements of l, from left to right.}
\end{itemize}

\item  \texttt{Definition map : (A -> B) -> list A -> list B}

\begin{itemize}
\item  \begin{flushleft} \texttt{map f l : applies f to each element of l from left to right, returning the list of results.} \end{flushleft}
\end{itemize}

\item   \texttt{Definition mapPartial : (A -> option B) -> list A -> list B}

\begin{itemize}
\item   \begin{flushleft} \texttt{mapPartial f l : applies f to each element of l from left to right, returning a list of results, with SOME stripped, where f was defined. f is not defined for an element of l if f applied to the element returns NONE. The above expression is equivalent to:} \end{flushleft}

\begin{itemize}
\item  \texttt{((map valOf) o (filter isSome) o (map f)) l}
\end{itemize}

\end{itemize}

\item \texttt{Definition find : (A -> bool) -> list A -> option A}

\begin{itemize}
\item  \begin{flushleft} \texttt{find f l : applies f to each element x of the list l, from left to right, until f x evaluates to true. It returns Some(x) if such an x exists; otherwise it returns None.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition filter : (A -> bool) -> list A -> list A}

\begin{itemize}
\item  \begin{flushleft} \texttt{filter f l : applies f to each element x of l, from left to right, and returns the list of those x for which f x evaluated to true, in the same order as they occurred in the argument list.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition partition : (A -> bool) -> list A -> list A * list A}

\begin{itemize}
\item  \begin{flushleft} \texttt{partition f l : applies f to each element x of l, from left to right, and returns a pair (pos, neg) where pos is the list of those x for which f x evaluated to true, and neg is the list of those for which f x evaluated to false. The elements of pos and neg retain the same relative order they possessed in l.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition foldl : (A * B -> B) -> B -> list A -> B}

\begin{itemize}
\item  \begin{flushleft} \texttt{foldl f init [\coqdocvar{x1}, \coqdocvar{x2}, ..., \coqdocvar{xn}] : returns f(xn,...,f(x2, f(x1, init))...) or init if the list is empty.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition foldr : (A * B -> B) -> B -> list A -> B}

\begin{itemize}
\item  \begin{flushleft} \texttt{foldr f init [\coqdocvar{x1}, \coqdocvar{x2}, ..., \coqdocvar{xn}] : returns f(x1, f(x2, ..., f(xn, init)...)) or init if the list is empty.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition existsb : (A -> bool) list A -> bool}

\begin{itemize}
\item  \begin{flushleft} \texttt{existsb f l : applies f to each element x of the list l, from left to right, until f x evaluates to true; it returns true if such an x exists and false otherwise.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition all f l : (A -> bool) list A -> bool}

\begin{itemize}
\item  \begin{flushleft} \texttt{all f l : applies f to each element x of the list l, from left to right, until f x evaluates to false; it returns false if such an x exists and true otherwise. It is equivalent to not(existsb (not o f) l)). } \end{flushleft}
\end{itemize}

\item  \texttt{Definition tabulate : nat * (Z -> A) -> list A}

\begin{itemize}
\item \begin{flushleft} \texttt{tabulate (n, f) : returns a list of length n equal to [\coqdocvar{f}(0), \coqdocvar{f}(1), ..., \coqdocvar{f}(\coqdocvar{n}-1)], created from left to right. It returns the axiom SizeException if n < 0.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition collate : (A * A -> order) -> list A * list A -> comparison}

\begin{itemize}
\item  \begin{flushleft} \texttt{collate f (l1, l2) :  performs lexicographic comparison of the two lists using the given ordering f on the list elements. } \end{flushleft}

\end{itemize}

\end{itemize}


\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\texttt{\coqdockw{End} \coqdocvar{List}.\coqdoceol}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{optionSml}{Library }{optionSml}
\section*{optionSml}

\begin{coqdoccode}
\coqdocnoindent
\texttt{\coqdockw{Module} \coqdocvar{Option}.\coqdoceol}
\coqdocemptyline
\end{coqdoccode}



\begin{itemize}
\item  \texttt{Axiom OptionException}



\item  \texttt{Definition getOpt : option A * A -> A}

\begin{itemize}
\item  \texttt{getOpt (opt, a) : returns v if opt is Some(v); otherwise it returns a.}
\end{itemize}

\item  \texttt{Definition isSome : option A -> bool}

\begin{itemize}
\item  \texttt{isSome opt : returns true if opt is Some(v); otherwise it returns false.}
\end{itemize}

\item  \texttt{Definition isSome : option A -> bool}

\begin{itemize}
\item  \texttt{isSome opt : returns true if opt is Some(v); otherwise it returns false.}
\end{itemize}

\item  \texttt{Definition valOf : option A -> A}

\begin{itemize}
\item \begin{flushleft} \texttt{valOf opt : returns v if opt is Some(v); otherwise it returns the Axiom OptionException.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition filter : (A -> bool) -> A -> option A}

\begin{itemize}
\item  \texttt{filter f a : returns Some(a) if f(a) is true and None otherwise.}
\end{itemize}

\item  \texttt{Definition join : option (option A) -> option A}

\begin{itemize}
\item  \texttt{join opt : The join function maps NONE to None and Some(v) to v.}
\end{itemize}

\item  \texttt{Definition app : (A -> unit) -> option A -> unit}

\begin{itemize}
\item  \begin{flushleft} \texttt{app f opt : applies the function f to the value v if opt is Some(v), and otherwise does nothing. } \end{flushleft}
\end{itemize}

\item  \texttt{Definition map : (A -> B) -> A option -> option B}

\begin{itemize}
\item  \texttt{map f opt : maps None to None and Some(v) to Some(f v).}
\end{itemize}

\item  \texttt{Definition mapPartial : (A -> option B) -> A option -> option B}

\begin{itemize}
\item  \begin{flushleft} \texttt{mapPartial f opt : maps None to None and Some(v) to f(v). The expression mapPartial f is equivalent to join o (map f).} \end{flushleft}



\end{itemize}

\item  \texttt{Definition compose : (A -> B) * (C -> option A) -> C -> option B}

\begin{itemize}
\item  \begin{flushleft} \texttt{mapPartial f opt : returns None if g(a) is None; otherwise, if g(a) is Some(v), it returns Some(f v).Thus, the compose function composes f with the partial function g to produce another partial function. The expression compose (f, g) is equivalent to (map f) o g. } \end{flushleft}



\end{itemize}

\item  \texttt{Definition composePartial :(A -> option B) * (C -> option A) -> C -> option B}

\begin{itemize}
\item  \begin{flushleft} \texttt{composePartial (f, g) a : returns None if g(a) is None; otherwise, if g(a) is Some(v), it returns f(v). Thus, the composePartial function composes the two partial functions f and g to produce another partial function. The expression composePartial (f, g) is equivalent to (mapPartial f) o g.} \end{flushleft}

\end{itemize}

\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\texttt{\coqdockw{End} \coqdocvar{Option}.\coqdoceol}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{realSml}{Library }{realSml}
\section*{realSml}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\texttt{\coqdockw{Module} \coqdocvar{Real}.\coqdoceol}
\coqdocemptyline
\end{coqdoccode}

\begin{itemize}
\item  \texttt{Axiom DomainException}

\item  \texttt{Axiom UnorderedException}

\item  \texttt{Axiom OverflowException}

\item  \texttt{Axiom DivException}

\item  \texttt{Definition radix : Z}

\begin{itemize}
\item  \texttt{The base of the representation, e.g., 2 or 10 for IEEE floating point.}
\end{itemize}

\item  \texttt{Definition precision : Z}

\begin{itemize}
\item  \begin{flushleft} \texttt{The number of digits, each between 0 and radix-1, in the mantissa. Note that the precision includes the implicit (or hidden) bit used in the IEEE representation (e.g., the value of Real64.precision is 53).} \end{flushleft}
\end{itemize}

\item  \texttt{Definition maxFinite : float}

\item  \texttt{Definition minPos : float}

\item  \texttt{Definition minNormalPos : float}

\begin{itemize}
\item  \begin{flushleft} \texttt{The maximum finite number, the minimum non-zero positive number, and the minimum non-zero normalized number, respectively.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition posInf : float}

\item  \texttt{Definition negInf : float}

\begin{itemize}
\item   \texttt{Positive and negative infinity values.}
\end{itemize}

\item  \texttt{Definition abs : float -> float} 

\begin{itemize}
\item  \texttt{abs r : returns the absolute value |r| of r.}

\begin{itemize}
\item  \texttt{abs (+-0.0) = +0.0 abs (+-infinity) = +infinity abs (+-nan) = +nan}
\end{itemize}

\end{itemize}

\item  \texttt{aDefinition min : float * float -> float}

\item  \texttt{aDefinition max : float * float -> float}

\begin{itemize}
\item  \begin{flushleft} \texttt{These return the smaller (respectively, larger) of the arguments. If exactly one argument is nan, they return the other argument. If both arguments are nan, they return nan.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition sign : float -> Z}

\begin{itemize}
\item  \begin{flushleft} \texttt{sign r : returns -1 if r is negative, 0 if r is zero, or 1 if r is positive. An infinity returns its sign; a zero returns 0 regardless of its sign. It returns the axiom DomainException on nan.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition signBit : float -> bool}

\begin{itemize}
\item  \begin{flushleft} \texttt{signBit r : returns true if and only if the sign of r (infinities, zeros, and nan, included) is negative.} \end{flushleft}

\end{itemize}

\item  \texttt{Definition sameSign : float * float -> bool}

\begin{itemize}
\item \begin{flushleft} \texttt{sameSign (r1, r2) : returns true if and only if signBit r1 equals signBit r2.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition copySign : float * float -> float}

\begin{itemize}
\item   \texttt{copySign (x, y) :  returns x with the sign of y, even if y is nan.}
\end{itemize}

\item  \texttt{Definition compare : float * float -> comparison}

\item  \texttt{Definition compareREal : float * float -> IEEEReal.real\_order}

\begin{itemize}
\item  \begin{flushleft} \texttt{The function compare returns Lt, Eq, or Gt according to whether its first argument is less than, equal to, or greater than the second. It returns the axiom UnorderedException on unordered arguments.\\
\coqdocemptyline
The function compareReal behaves similarly except that the values it returns have the extended type IEEEReal.real\_order and it returns IEEEReal.UNORDERED on unordered arguments.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition unordered : float * float -> bool}

\begin{itemize}
\item  \begin{flushleft} \texttt{unordered (x, y) : returns true if x and y are unordered, i.e., at least one of x and y is nan.} \end{flushleft}
\end{itemize}

\item  \texttt{Definition isFinite : float -> bool}

\begin{itemize}
\item  \texttt{isFinite x :  returns true if x is neither nan nor an infinity.}



\end{itemize}

\item  \texttt{Definition isNan : float -> bool}

\begin{itemize}
\item  \texttt{isNan x : returns true if x is nan.}



\end{itemize}

\item  \texttt{Definition isNormal : float -> bool}

\begin{itemize}
\item  \begin{flushleft} \texttt{isNormal x : returns true if x is normal, i.e., neither zero, subnormal, infinite nor nan.} \end{flushleft}



\end{itemize}

\item  \texttt{Definition class : real -> IEEEReal.float\_class}

\begin{itemize}
\item  \texttt{class x : returns the IEEEReal.float\_class to which x belongs.}
\end{itemize}

\item  \texttt{Record flt : Set := mkflt \{ man : float; exp : BinNums.Z\}.}



\item  \texttt{Definition toManExp : float -> Real.flt}

\begin{itemize}
\item   \begin{flushleft} \texttt{toManExp r : returns \{man, exp\}, where man and exp are the mantissa and exponent of r, respectively. Specifically, we have the relation}  \end{flushleft}

\begin{itemize}
\item \texttt{ r = man * radix(exp) }

\end{itemize}

\texttt{where 1.0 <= man * radix < radix. This function is comparable to frexp in the C library.}

 \begin{flushleft} \texttt{ If r is +-0, man is +-0 and exp is +0. If r is +-infinity, man is +-infinity and exp is unspecified. If r is nan, man is nan and exp is unspecified.}  \end{flushleft}

\end{itemize}

\item  \texttt{Definition fromManExp : Real.flt -> float}

\begin{itemize}
\item   \begin{flushleft} \texttt{fromManExp \{| man; exp |\} : returns man * radix(exp). This function is comparable to ldexp in the C library. Note that, even if man is a non-zero, finite real value, the result of fromManExp can be zero or infinity because of underflows and overflows.}  \end{flushleft}

 \begin{flushleft} \texttt{If man is +-0, the result is +-0. If man is +-infinity, the result is +-infinity. If man is nan, the result is nan. }  \end{flushleft}

\end{itemize}

\item \texttt{ Record nmbr : Set := mknmbr \{ whole : float; frac : float\}.}



\item  \texttt{Definition split : float -> Real.nmbr}

\item  \texttt{Definition realMod : float -> float}

\begin{itemize}
\item  \texttt{split r}

\item  \texttt{realMod r}

\begin{itemize}
\item   \begin{flushleft} \texttt{The former returns \{whole, frac\}, where frac and whole are the fractional and integral parts of r, respectively. Specifically, whole is integral, |frac| < 1.0, whole and frac have the same sign as r, and r = whole + frac. This function is comparable to modf in the C library.}

\texttt{  If r is +-infinity, whole is +-infinity and frac is +-0. If r is nan, both whole and frac are nan.}  \end{flushleft}



\end{itemize}

\end{itemize}

\item  \texttt{Definition nextAfter : float * float -> float}

\begin{itemize}
\item  \begin{flushleft} \texttt{nextAfter (r, t) : returns the next representable real after r in the direction of t. Thus, if t is less than r, nextAfter returns the largest representable floating-point number less than r. If r = t then it returns r. If either argument is nan, this returns nan. If r is +-infinity, it returns +-infinity. } \end{flushleft}



\end{itemize}

\item  \texttt{Definition checkFloat : float -> float}

\begin{itemize}
\item \begin{flushleft} \texttt{checkFloat x : returns the axiom OverflowException if x is an infinity, and returns the axiom DivException if x is nan. Otherwise, it returns its argument.} \end{flushleft}

\end{itemize}

\item  \texttt{Definition realFloor : float -> float}

\item \texttt{ Definition realCeil : float -> float}

\item  \texttt{Definition realTrunc : float -> float}

\item  \texttt{Definition realRound : float -> float}

\begin{itemize}
\item  \texttt{realFloor r}

\item \texttt{ realCeil r}

\item  \texttt{realTrunc r}

\item  \texttt{realRound r}

\begin{itemize}
\item  \begin{flushleft} \texttt{These functions convert real values to integer-valued reals. realFloor produces floor(r), the largest integer not larger than r. realCeil produces ceil(r), the smallest integer not less than r. realTrunc rounds r towards zero, and realRound rounds to the integer-values real value that is nearest to r. If r is nan or an infinity, these functions return r.} \end{flushleft}

\end{itemize}

\end{itemize}

\item  \texttt{Definition floor : float -> nat -> Z}

\item  \texttt{Definition ceil : float -> nat -> Z}

\item  \texttt{Definition trunc : float -> nat -> Z}

\item  \texttt{Definition round : float -> nat -> Z}

\begin{itemize}
\item  \texttt{floor nd r}

\item  \texttt{ceil nd r}

\item  \texttt{trunc nd r}

\item  \texttt{round nd r}

\begin{itemize}
\item  \begin{flushleft} \texttt{These functions convert reals to integers. floor produces floor(r), the largest int not larger than r. ceil produces ceil(r), the smallest int not less than r. trunc rounds r towards zero. round yields the integer nearest to r. In the case of a tie, it rounds to the nearest even integer.They return the axiom OverflowException if the resulting value cannot be represented as an int, for example, on infinity. They return the axiom DomainException on nan arguments. } \end{flushleft}

\item   \texttt{These are respectively equivalent to:}

\begin{itemize}

\item  \texttt{toInt IEEEReal.TO\_NEGINF r}

\item  \texttt{toInt IEEEReal.TO\_POSINF r}

\item  \texttt{toInt IEEEReal.TO\_ZERO r}

\item  \texttt{toInt IEEEReal.TO\_NEAREST r}

\end{itemize}

\item  \texttt{The parameter nd is the number of digits in r (excluding . ).}

\end{itemize}

\end{itemize}

\item  \texttt{Definition toInt : rounding\_mode -> float -> nat -> Z}

\item  \texttt{Definition toLargeInt : rounding\_mode -> float -> nat -> Z}

\begin{itemize}
\item  \texttt{toInt mode nd x}

\item  \texttt{toLargeInt mode nd x}

\begin{itemize}
\item  \begin{flushleft} \texttt{These functions convert the argument x to an integral type using the specified rounding mode. They return the axiom OverflowException if the result is not representable, in particular, if x is an infinity. They return the axiom DomainException if the input real is nan.} \end{flushleft}

\item  \texttt{The parameter nd is the number of digits in r (excluding . ).}

\end{itemize}

\end{itemize}

\item  \texttt{Definition toLarge : Z -> float}

\item \texttt{ Definition fromLargeInt :  Z -> float}

\begin{itemize}
\item  \texttt{fromInt i }

\item  \texttt{fromLargeInt i}

\begin{itemize}
\item  \begin{flushleft} \texttt{These functions convert the integer i to a real value. If i cannot be exactly represented as a real value, then the current rounding mode is used to determine the resulting value.} \end{flushleft} 



\end{itemize}

\end{itemize}

\item  \texttt{Definition toLarge : float -> float}

\item  \texttt{Definition fromLarge : IEEEReal.rounding\_mode -> float -> float}

\begin{itemize}
\item  \texttt{toLarge r}

\item  \texttt{fromLarge r}

\begin{itemize}
\item  \texttt{returns r.}



\end{itemize}

\end{itemize}

\item  \texttt{Definition fmt : StringCvt.radix -> float -> nat -> string}

\item  \texttt{Definition toString :  float -> nat -> string}

\begin{itemize}
\item  \texttt{fmt spec nd r}

\item  \texttt{toString nd r}

\begin{itemize}
\item \begin{flushleft} \texttt{These functions convert reals into strings. The conversion provided by the function fmt is parameterized by spec, which has the following forms and interpretations.} \end{flushleft}

\item  \texttt{SCI arg}

\begin{itemize}
\item  \texttt{Scientific notation:} $[-]^?[0-9].[0-9]^{+?}\text{E}[0-9]^+$
\item  \begin{flushleft} \texttt{where there is always one digit before the decimal point, nonzero if the number is nonzero. arg specifies the number of digits to appear after the decimal point, with 6 the default if arg is None. If arg is Some(0), no fractional digits and no decimal point are printed.}\end{flushleft}

\end{itemize}

\item  \texttt{Fix arg}

\begin{itemize}
\item  \texttt{Fixed-point notation:} $[-]^?[0-9]^+.[0-9]^{+?}$


\item  \begin{flushleft}\texttt{arg specifies the number of digits to appear after the decimal point, with 6 the default if arg is None. If arg is Some(0), no fractional digits and no decimal point are printed. } \end{flushleft}

\end{itemize}

\item  \texttt{GEN arg}

\begin{itemize}
\item  \begin{flushleft} \texttt{Adaptive notation: the notation used is either scientific or fixed-point depending on the value converted. arg specifies the maximum number of significant digits used, with 12 the default if arg is None.} \end{flushleft}



\end{itemize}

\item  \texttt{EXACT}

\begin{itemize}
\item  \begin{flushleft} \texttt{Exact decimal notation: refer to IEEEReal.toString for a complete description of this format. }\end{flushleft}

\end{itemize}

\item  \begin{flushleft}\texttt{In all cases, positive and negative infinities are converted to "inf" and "-inf", respectively, and nan values are converted to the string "nan". }\end{flushleft}

\item \begin{flushleft}\texttt{ Refer to StringCvt.realfmt for more details concerning these formats, especially the adaptive format GEN. }\end{flushleft}

\item  \texttt{The value returned by toString is equivalent to:}

\begin{itemize}
\item  \texttt{(fmt (StringCvt.GEN NONE) r)}



\end{itemize}

\end{itemize}

\end{itemize}

\item \texttt{ Definition sccan : Not Implemented}

\item  \texttt{Definition fromString : string -> option float}

\begin{itemize}
\item  \begin{flushleft}\texttt{fromString s :  returns Some(r) if a real value can be scanned from a prefix of s, ignoring any initial whitespace; otherwise, it returns None.}\end{flushleft}

\item  \texttt{The functions accept real numbers with the following format:}

\begin{itemize}
\item  $[+ \textasciitilde{} -]^?([0-9]^+.[0-9]^+? | .[0-9]^+)(e|E)[+ \textasciitilde{} -]^?[0-9]^+$

\end{itemize}

\item \texttt{ It also accepts the following string representations of non-finite} values:

\begin{itemize}
\item $[+ \textasciitilde{} -]^?(\text{inf | infinity | nan})$

\end{itemize}

\item  \texttt{where the alphabetic characters are case-insensitive.}



\end{itemize}

\item  \texttt{Definition toDecimal : real -> nat -> IEEEReal.decimal\_approx}

\item \texttt{ Definition fromDecimal : IEEEReal.decimal\_approx -> option float}

\begin{itemize}
\item  \texttt{toDecimal r nd}

\item  \texttt{fromDecimal d}

\begin{itemize}
\item  \begin{flushleft} \texttt{These convert between real values and decimal approximations. Decimal approximations are to be converted using the IEEEReal.TO\_NEAREST rounding mode. toDecimal should produce only as many digits as are necessary for fromDecimal to convert back to the same number. }
\coqdocemptyline

\texttt{For toDecimal, when the r is not normal or subnormal, then the exp field is set to 0 and the digits field is the empty list. In all cases, the sign and class field capture the sign and class of r. }
\coqdocemptyline

\texttt{For fromDecimal, if class is ZERO or INF, the resulting real is the appropriate signed zero or infinity. If class is NAN, a signed nan is generated. If class is NORMAL or SUBNORMAL, the sign, digits and exp fields are used to produce a real number whose value is. }\end{flushleft}
\coqdocemptyline

\begin{itemize}
\item  \texttt{s * 0.d(1)d(2)...d(n) $10^{(exp)}$}

\end{itemize}

\begin{flushleft} \texttt{where digits = \coqdocvar{d}(1), \coqdocvar{d}(2), ..., \coqdocvar{d}(\coqdocvar{n}) and where s is -1 if sign is true and 1 otherwise. Note that the conversion itself should ignore the class field, so that the resulting value might have class NORMAL, SUBNORMAL, ZERO, or INF. For example, if digits is empty or a list of all 0's, the result should be a signed zero. }
\coqdocemptyline

\texttt{If the argument to fromDecimal does not have a valid format, i.e., if the digits field contains integers outside the range 0,9, it returns None.}
 \end{flushleft}

\end{itemize}

\end{itemize}

\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\texttt{\coqdockw{End} \coqdocvar{Real}.\coqdoceol}
\coqdocemptyline
\end{coqdoccode}
\coqlibrary{stringSml}{Library }{stringSml}
\section*{stringSml}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Module} \coqdocvar{String}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}



\begin{itemize}
\item  \texttt{Axiom  SubscriptException}

\item  \texttt{Axiom  SizeException}

\item  \texttt{Definition maxSize : Z}

\begin{itemize}
\item  \texttt{The longest allowed size of a string.}

\end{itemize}

\item  \texttt{Definition size : string -> Z}

\begin{itemize}
\item  \texttt{size s : returns |s|, the number of characters in string s.}

\end{itemize}

\item  \texttt{Definition sub : string * Z -> ascii}

\begin{itemize}
\item  \begin{flushleft} \texttt{sub (s, i) : returns the i(th) character of s, counting from zero. This returns the axiom SubscriptException if i < 0 or |s| <= i.} \end{flushleft} 

\end{itemize}

\item  \texttt{Definition extract : string * Z * option Z -> string}

\item  \texttt{Definition substring : string * Z * Z -> string}

\begin{itemize}
\item  \texttt{extract (s, i, None)}

\item  \texttt{extract (s, i, Some j)}

\item  \texttt{substring (s, i, j)}

\begin{itemize}
\item  \begin{flushleft} \texttt{These return substrings of s. The first returns the substring of s from the i(th) character to the end of the string, i.e., the string s\coqdocvar{i}..|\coqdocvar{s}|-1. This returns the axiom SubscriptException if i < 0 or |s| < i. The second form returns the substring of size j starting at index i, i.e., the string s\coqdocvar{i}..\coqdocvar{i}+\coqdocvar{j}-1. It returns the axiom SubscriptException if i < 0 or j < 0 or |s| < i + j. Note that, if defined, extract returns the empty string when i = |s|.\\
The third form returns the substring s\coqdocvar{i}..\coqdocvar{i}+\coqdocvar{j}-1, i.e., the substring of size j starting at index i. This is equivalent to extract(s, i, Some j).}\end{flushleft}

\end{itemize}

\end{itemize}

\item  \texttt{Definition concat : list string -> string}

\begin{itemize}
\item  \begin{flushleft} \texttt{concat l : is the concatenation of all the strings in l. This returns the axiom SizeException if the sum of all the sizes is greater than maxSize.} \end{flushleft}

\end{itemize}

\item  \texttt{Definition concatWith : string -> list string -> string}

\begin{itemize}
\item \begin{flushleft} \texttt{concatWith s l : returns the concatenation of the strings in the list l using the string s as a separator. This returns the axiom SizeException if the size of the resulting string would be greater than maxSize. } \end{flushleft}

\end{itemize}

\item  \texttt{Definition str : ascii -> string}

\begin{itemize}
\item  \texttt{str c : is the string of size one containing the character c.}

\end{itemize}

\item  \texttt{Definition implode : list ascii -> string}

\begin{itemize}
\item \begin{flushleft} \texttt{implode l : generates the string containing the characters in the list l. This is equivalent to concat (List.map str l). This returns the axiom SizeException if the resulting string would have size greater than maxSize.} \end{flushleft}

\end{itemize}

\item  \texttt{Definition explode : string -> list ascii}

\begin{itemize}
\item  \texttt{explode s : is the list of characters in the string s.}

\end{itemize}

\item  \texttt{Definition map : (ascii -> ascii) -> string -> string}

\begin{itemize}
\item  \begin{flushleft} \texttt{map f s : applies f to each element of s from left to right, returning the resulting string. It is equivalent to implode(List.map f (explode s)).} \end{flushleft}

\end{itemize}

\item  \texttt{Definition translate : (ascii -> string) -> string -> string}

\begin{itemize}
\item  \begin{flushleft} \texttt{translate f s : returns the string generated from s by mapping each character in s by f. It is equivalent to concat(List.map f (explode s)).} \end{flushleft}

\end{itemize}

\item  \texttt{Definition tokens : (ascii -> bool) -> string -> list string}

\item  \texttt{Definition fields : (ascii -> bool) -> string -> list string}

\begin{itemize}
\item  \texttt{tokens f s}

\item  \texttt{fields f s}

\begin{itemize}
\item  \begin{flushleft} \texttt{These functions return a list of tokens or fields, respectively, derived from s from left to right. A token is a non-empty maximal substring of s not containing any delimiter. A field is a (possibly empty) maximal substring of s not containing any delimiter. In both cases, a delimiter is a character satisfying the predicate f.\\
\coqdocemptyline
Two tokens may be separated by more than one delimiter, whereas two fields are separated by exactly one delimiter. For example, if the only delimiter is the character  \#"|", then the string "|abc||def" contains two tokens "abc" and "def", whereas it contains the four fields "", "abc", "" and "def".}  \end{flushleft}
\end{itemize}

\end{itemize}

\item \texttt{Definition isPrefix : string -> string -> bool}
\item \texttt{Definition isSubstring : string -> string -> bool}
\item \texttt{Definition isSuffix : string -> string -> bool}

\begin{itemize}
\item \texttt{isPrefix s1 s2}
\item \texttt{isSubstring s1 s2}
\item \texttt{isSuffix s1 s2 }

\begin{itemize}
\item \begin{flushleft} \texttt{These functions return true if the string s1 is a prefix, substring, or suffix (respectively) of the string s2. Note that the empty string is a prefix, substring, and suffix of any string, and that a string is a prefix, substring, and suffix of itself.}\end{flushleft}
\end{itemize}

\end{itemize}

\item \texttt{Definition compare : string * string -> comparison}
    
\begin{itemize}
\item \begin{flushleft} \texttt{compare (s, t) : does a lexicographic comparison of the two strings using the ordering Char.compare on the characters. It returns Lt, Eq, or Gt, if s is less than, equal to, or greater than t, respectively.} \end{flushleft}
\end{itemize}    
    

\item \begin{flushleft}\texttt{Definition collate : (ascii * ascii -> comparison) -> string * string -> comparison}\end{flushleft}

\begin{itemize}
\item \begin{flushleft} \texttt{performs lexicographic comparison of the two strings using the given ordering f on characters.}\end{flushleft}
\end{itemize}
    
\item \texttt{Definition toString : string -> string}

\begin{itemize}
\item \texttt{toString s : returns s.}
\end{itemize}
  
\item \texttt{Definition scan : Not Implemented}

\item \texttt{Definition fromString : string -> option string}

\begin{itemize}
\item \texttt{fromString s : returns s.}
\end{itemize}    
       

 
    
    
    
\end{itemize}
\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\coqdocnoindent
\texttt{\coqdockw{End} \coqdocvar{String}.\coqdoceol}
\coqdocemptyline
\end{coqdoccode}
\end{document}
