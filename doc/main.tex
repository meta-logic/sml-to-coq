\documentclass[a4paper,11pt]{article}

\usepackage{hyperref}
\usepackage{proof}
\usepackage{amsmath}
\usepackage[dvipsnames]{xcolor}
\usepackage{listings}

\usepackage{Coq}
\usepackage{SML}
% For grammars
\lstdefinelanguage{grammar}{
  basicstyle=\footnotesize\ttfamily,
  %
  captionpos=b,
  % 
  tabsize=2,
  %
  columns=fixed,
  %
  breaklines=true,
  %
  frame=l,
  %
  morecomment=[s]{/*}{*/},
  %
  stringstyle=\color{black},
  %
  identifierstyle=\ttfamily,
  %
  otherkeywords= {=>, ;},
  %
  morekeywords= {
    EQUAL, GREATER, LESS, NONE, SOME, 
    abstraction, abstype, and, andalso, 
    array, as, before, bool, case, char, 
    datatype, do, else, end, eqtype, 
    exception, exn, false, fn, fun, 
    functor, handle, if, in, include, 
    infix, infixr, int, let, list, local, 
    nil, nonfix, not, o, of, op, open, 
    option, orelse, overload, print, 
    raise, real, rec, ref, sharing, sig, 
    signature, string, struct, structure, 
    substring, then, true, type, unit, val, 
    vector, where, while, with, withtype, word
  },
  %
  keywordstyle=\ttfamily\color{red},
  %
  commentstyle=\ttfamily\color{gray},
  % Spaces are not displayed as a special character
  showstringspaces=false,
  %
  mathescape=true,
  %
  escapeinside={!}{!}
}
\lstnewenvironment{grm}{\lstset{language=grammar}}{}

\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommand{\giselle}[1]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum]{G: #1}}

\title{Translation of SML programs into Coq programs}
\date{}

\begin{document}
\maketitle

The goal of this document is to define formally the translation of SML programs,
represented by their abstract syntax tree (AST) into Coq programs, represented
by Gallina's AST. Before defining the translation, we specify the two ASTs in
question.
\giselle{TODO: better introduction, mention the tools we used and motivation.}

% Testing environments:
% 
% \begin{sml}
% datatype 'a tree = Empty
%                  | Node of 'a tree * 'a * 'a tree
% \end{sml}
% 
% \begin{coq}
% Definition g y := 
%   match (cons 1 nil) with
%     | (x :: l) => x + y
%     | _ => patternFailure
%   end.
% \end{coq}

\section{HaMLet}

HaMLet~\cite{hamlet} is an SML implementation whose goal is to be an accurate
implementation of the language definition~\cite{smldef}, and a platform for
experimentation. There are two main reasons why we chose it for this work. First
of all, it is faithful to SML's definition, and all bugs and ``grey areas'' and
well documented. Secondly, it is easy to access various steps of the compilation
process. Particularly, the abstract syntax tree from the elaboration phase was
readily available.

In order to have a translation as precise as possible, we needed a few
modifications in HaMLet. All changes were related to derived
forms.\giselle{check if this is still the case at the end.}
Derived forms are SML expressions that can be replaced by equivalent forms
during parsing, resulting in SML parse trees that are formed by only a subset of
the constructs in syntax trees. For example, boolean operators can be replaced by
the equivalent \smle{if ... then ... else}:

\begin{center}
\begin{tabular}{rcl}
{\smle|$e_1$ orelse $e_2$|}  & $\Rightarrow$ & {\smle|if $e_1$ then true else $e_2$|} \\
{\smle|$e_1$ andalso $e_2$|} & $\Rightarrow$ & {\smle|if $e_1$ then $e_2$ else false|}
\end{tabular}
\end{center}

HaMLet translates the derived forms as specified in SML's definition.
Translating this subset of SML's syntax to Coq is correct -- semantically
speaking -- however, the resulting Coq code will look very different: an
\smle{orelse} expression will be translated to an \coqe{if...then...else}
expression. Thus, we decided to keep the original grammatical form and
translate that to Gallina.

Even though the translation is done on the abstract syntax tree with the derived
forms, we still need to make sure that the code type checks and runs.
Additionally, the elaboration phase provides crucial information for the
translation, such as non-exhaustive match warnings. These two phases do not
consider the derived forms. This problem is solved by one of two approaches,
depending on the construct: (1) the derived form is replaced by the equivalent
form, and we interpret any needed information in the context of the derived
form; or (2) we implement an extra case for the derived form when it is
straighforward.

% all modifications are sound.

\section{SML's abstract syntax tree}

The datatypes used for SML's abstract syntax tree is defined in the file
\texttt{hamlet/syntax/SyntaxCoreFn.sml}. It is reproduced here in a grammar
format, and whenever possible we have used the same datatype names. Whenever
possible the actual SML syntax is used for clarity.

Elements in $\langle\rangle$ are optional.

% Constructors ending in X are Laila's additions
\giselle{Unit is the empty tuple. Why do we need it as a separate entity?}
\begin{grm}
/* Special Constants */
SCon ::= /* integer, real, word, strings, 
            and character constants (e.g. 42) */

/* Type Constructors */
TyCon ::= unit
        | bool
        | int
        | word
        | real
        | string
        | char
        | list
        | ref
        | exn
        | /* valid names for types */

Id ::= /* allowed identifiers -- longVId or VId */

/* Atomic Expressions */
AtExp ::= SpecialConst 
        | op Id 
        | Id 
        | {Lab: Exp, Lab: Exp, ...} 
        | let Dec in Exp end 
        | (Exp) 
        /* Added expressions (translated to records originally) */
        | () 
        | (Exp, Exp, ...) 
        | [Exp, Exp, ...]

/* Expressions */
Exp ::= AtExp 
      | Exp AtExp 
      | Exp : Ty 
      | Exp handle Match
      | raise Exp 
      | fn Match
      /* Added expressions (derived forms) */
      | case Exp of Match 
      | if Exp then Exp else Exp
      | Exp andalso Exp 
      | Exp orelse Exp

/* Pattern matching */
Match ::= Pat => Exp !$\langle$! | Match !$\rangle$!

/* Declarations */
Dec ::= val TyVarSeq ValBind /* E.g. val 'a x = 5 */
      | type TypBind
      | datatype DatBind
      | datatype TyCon = datatype <longtycon>
      | abstype Datbind with Dec end
      | exception ExBind
      | local Dec in Dec end
      | open <longstrid> ... <longstrid>
      | !$\varepsilon$!
      | Dec ; Dec
      
/* Value binding */
ValBind ::= Pat = Exp !$\langle$! and ValBind !$\rangle$!
          | rec ValBind

/* Type binding */
TypBind ::= TyVarSeq TyCon = Ty !$\langle$! and TypBind !$\rangle$!

/* Data binding */
DatBind ::= TyVarSeq TyCon = ConBind !$\langle$! and DatBind !$\rangle$!

/* Not an actual datatype in the implementation */
TyVarSeq ::= !$\varepsilon$!
           | TyVar
           | (TyVar, TyVar, ...)

/* Constructor binding */
ConBind ::= !$\langle$! op !$\rangle$! Id !$\langle$! of Ty !$\rangle$! !$\langle$! | ConBind !$\rangle$!

/* Exception binding */
ExBind ::= !$\langle$! op !$\rangle$! Id !$\langle$! of Ty !$\rangle$! !$\langle$! and ExBind !$\rangle$!
         | !$\langle$! op !$\rangle$! Id = !$\langle$! Id !$\rangle$! !$\langle$! and ExBind !$\rangle$!



  (* Patterns [Figures 2 and 3] *)

  and AtPat' =
      WILDCARDAtPat
    | SCONAtPat   of SCon
    | IDAtPat     of Op option * longVId
    | RECORDAtPat of PatRow option
    | PARAtPat    of Pat
    | UNITAtPatX
    | TUPLEAtPatX of Pat list
    | LISTAtPatX of Pat list


  and PatRow' =
      DOTSPatRow
    | FIELDPatRow of Lab * Pat * PatRow option

  and Pat' =
      ATPat       of AtPat
    | CONPat      of Op option * longVId * AtPat
    | COLONPat    of Pat * Ty
    | ASPat       of Op option * VId * Ty option * Pat


  (* Type expressions [Figures 2 and 3] *)

  and Ty' =
      VARTy    of TyVar
    | RECORDTy of TyRow option
    | CONTy    of Ty seq * longTyCon
    | ARROWTy  of Ty * Ty
    | PARTy    of Ty
    | TUPLETyX  of Ty list

  and TyRow' =
      TyRow    of Lab * Ty * TyRow option
\end{grm}

\section{Gallina's abstract syntax tree}

\bibliography{references}{}
\bibliographystyle{abbrv}

\end{document}
