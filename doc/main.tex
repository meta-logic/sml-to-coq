\documentclass[a4paper,11pt]{article}

\usepackage{hyperref}
\usepackage{proof}
\usepackage{amsmath}
\usepackage[dvipsnames]{xcolor}
\usepackage{listings}

\usepackage{Coq}
\usepackage{SML}
% For grammars
\lstdefinelanguage{grammar}{
  basicstyle=\footnotesize\ttfamily,
  %
  captionpos=b,
  % 
  tabsize=2,
  %
  columns=fixed,
  %
  breaklines=true,
  %
  frame=l,
  %
  morecomment=[s]{/*}{*/},
  %
  stringstyle=\color{black},
  %
  identifierstyle=\ttfamily,
  %
  otherkeywords= {=>, ;},
  %
  morekeywords= {
    EQUAL, GREATER, LESS, NONE, SOME, 
    abstraction, abstype, and, andalso, 
    array, as, before, bool, case, char, 
    datatype, do, else, end, eqtype, 
    exception, exn, false, fn, fun, 
    functor, handle, if, in, include, 
    infix, infixr, int, let, list, local, 
    nil, nonfix, not, o, of, op, open, 
    option, orelse, overload, print, 
    raise, real, rec, ref, sharing, sig, 
    signature, string, struct, structure, 
    substring, then, true, type, unit, val, 
    vector, where, while, with, withtype, word
  },
  %
  keywordstyle=\ttfamily\color{red},
  %
  commentstyle=\ttfamily\color{gray},
  % Spaces are not displayed as a special character
  showstringspaces=false,
  %
  mathescape=true,
  %
  escapeinside={!}{!}
}
\lstnewenvironment{grm}{\lstset{language=grammar}}{}

\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommand{\giselle}[1]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum]{G: #1}}

\title{Translation of SML programs into Coq programs}
\date{}

\begin{document}
\maketitle

The goal of this document is to define formally the translation of SML programs,
represented by their abstract syntax tree (AST) into Coq programs, represented
by Gallina's AST. Before defining the translation, we specify the two ASTs in
question.
\giselle{TODO: better introduction, mention the tools we used and motivation.}

% Testing environments:
% 
% \begin{sml}
% datatype 'a tree = Empty
%                  | Node of 'a tree * 'a * 'a tree
% \end{sml}
% 
% \begin{coq}
% Definition g y := 
%   match (cons 1 nil) with
%     | (x :: l) => x + y
%     | _ => patternFailure
%   end.
% \end{coq}

\section{HaMLet}

HaMLet~\cite{hamlet} is an SML implementation whose goal is to be an accurate
implementation of the language definition~\cite{smldef}, and a platform for
experimentation. There are two main reasons why we chose it for this work. First
of all, it is faithful to SML's definition, and all bugs and ``grey areas'' and
well documented. Secondly, it is easy to access various steps of the compilation
process. Particularly, the abstract syntax tree from the elaboration phase was
readily available.

In order to have a translation as precise as possible, we needed a few
modifications in HaMLet. All changes were related to derived
forms.\giselle{check if this is still the case at the end.}
Derived forms are SML expressions that can be replaced by equivalent forms
during parsing, resulting in SML parse trees that are formed by only a subset of
the constructs in syntax trees. For example, boolean operators can be replaced by
the equivalent \smle{if ... then ... else}:

\begin{center}
\begin{tabular}{rcl}
{\smle|$e_1$ orelse $e_2$|}  & $\Rightarrow$ & {\smle|if $e_1$ then true else $e_2$|} \\
{\smle|$e_1$ andalso $e_2$|} & $\Rightarrow$ & {\smle|if $e_1$ then $e_2$ else false|}
\end{tabular}
\end{center}

HaMLet translates the derived forms as specified in SML's definition.
Translating this subset of SML's syntax to Coq is correct -- semantically
speaking -- however, the resulting Coq code will look very different: an
\smle{orelse} expression will be translated into an \coqe{if...then...else}
expression. Therefore, we decided to keep the original grammatical form and
translate that to Gallina.

Even though the translation is done on the abstract syntax tree with the derived
forms, we still need to make sure that the code type checks and runs.
Additionally, the elaboration phase provides crucial information for the
translation, such as non-exhaustive match warnings. These two phases do not
consider the derived forms. This problem is solved by one of two approaches,
depending on the construct: (1) the derived form is replaced by the equivalent
form, and we interpret any needed information in the context of the derived
form; or (2) we implement an extra case for the derived form when it is
straighforward.

% all modifications are sound.

\section{SML's abstract syntax tree}

The datatypes used for SML's abstract syntax tree is defined in the file
\texttt{hamlet/syntax/SyntaxCoreFn.sml}. It is reproduced here in a grammar
format, where the same datatype names are used, and SML keywords are explicit.

Elements in $\langle\rangle$ are optional.

% Constructors ending in X are Laila's additions
\giselle{Unit is the empty tuple. Why do we need it as a separate entity?}
\begin{grm}
/* Special Constants */
SCon ::= /* integer, real, word, strings, 
            and character constants (e.g. 42) */

/* Type Constructors */
TyCon ::= unit   | bool | int  | word | real
        | string | char | list | ref  | exn
        | /* valid names for types */

/* Names and identifiers */
VId   ::= /* allowed value identifiers */
StrId ::= /* allowed structure identifiers */
Lab   ::= /* allowed record labels */
TyVar ::= /* allowed type variable names */

/* Atomic Expressions */
AtExp ::= SCon 
        | op VId 
        | VId 
        | {Lab: Exp, Lab: Exp, ...} 
        | let Dec in Exp end 
        | (Exp) 
        /* Added expressions (records in hamlet) */
        | () 
        | (Exp, Exp, ...) 
        | [Exp, Exp, ...]

/* Expressions */
Exp ::= AtExp 
      | Exp AtExp 
      | Exp : Ty 
      | Exp handle Match
      | raise Exp 
      | fn Match
      /* Added expressions (derived forms) */
      | case Exp of Match 
      | if Exp then Exp else Exp
      | Exp andalso Exp 
      | Exp orelse Exp

/* Pattern matching */
Match ::= Pat => Exp !$\langle$!| Match!$\rangle$!

/* Declarations */
Dec ::= val !$\langle$!TyVar!$\rangle^*$! ValBind /* E.g. val 'a x = 5 */
      | type TypBind
      | datatype DatBind
      | datatype TyCon = datatype TyCon
      | abstype Datbind with Dec end
      | exception ExBind
      | local Dec in Dec end
      | open StrId ... StrId
      | !$\varepsilon$!
      | Dec ; Dec
      
/* Value binding */
ValBind ::= Pat = Exp !$\langle$!and ValBind!$\rangle$!
          | rec ValBind

/* Type binding */
TypBind ::= !$\langle$!TyVar!$\rangle^*$!  TyCon = Ty !$\langle$!and TypBind!$\rangle$!

/* Data binding */
DatBind ::= !$\langle$!TyVar!$\rangle^*$!  TyCon = ConBind !$\langle$!and DatBind!$\rangle$!

/* Constructor binding */
ConBind ::= !$\langle$!op!$\rangle$! VId !$\langle$!of Ty!$\rangle$! !$\langle$!| ConBind!$\rangle$!

/* Exception binding */
ExBind ::= !$\langle$!op!$\rangle$! VId !$\langle$!of Ty!$\rangle$! !$\langle$!and ExBind!$\rangle$!
         | !$\langle$!op!$\rangle$! VId = !$\langle$!VId!$\rangle$! !$\langle$!and ExBind!$\rangle$!

/* Atomic Patterns */
AtPat ::= _ 
        | SCon
        | !$\langle$!op!$\rangle$! VId 
        | { !$\langle$!PatRow!$\rangle$! }
        | ( Pat )
        /* Added patterns (translated to records originally) */
        | ()
        | (Pat, Pat, ...)
        | [Pat, Pat, ...]

/* Record Patterns */
PatRow ::= ... /* Wildcard for records */
         | Lab = Pat !$\langle$!, PatRow!$\rangle$!

/* Patterns */
Pat ::= AtPat
      | !$\langle$!op!$\rangle$! VId AtPat
      | Pat : Ty
      | !$\langle$!op!$\rangle$! VId !$\langle$!: Ty!$\rangle$! as pat

/* Types */
Ty ::= TyVar
     | { TyRow }
     | !$\langle$!Ty!$\rangle^*$! TyCon /* e.g. 'a, 'b Tree */
     | Ty -> Ty
     | (Ty)
     /* Added types */
     | (Ty, Ty, ...)

/* Record Types */
TyRow ::= Lab : Ty !$\langle$!, TyRow!$\rangle$!
\end{grm}

\section{Gallina's abstract syntax tree}

The grammar format is copied from Coq's reference manual (The Gallina
specification language).\giselle{Acutally, the grammar that we use is slightly
different from the one in Gallina's specification. We should describe our
grammar and highlight the differences.}

``An expression enclosed in square brackets [...] means at
most one occurrence of this expression (this corresponds to an optional
component). The notation ``entry sep ... sep entry'' stands for a non empty sequence
of expressions parsed by entry and separated by the literal ``sep''. Similarly,
the notation ``entry ... entry'' stands for a non empty sequence of expressions
parsed by the ``entry'' entry, without any separator between.''


\begin{grm}
/* Identifiers */
ident :			  ::= first_letter[subsequent_letter...subsequent_letter]
field             ::=  .ident
first_letter      ::=  a..z | A..Z | _ | unicode_letter 
subsequent_letter ::=  first_letter| 0..9| ' | unicode_id_part
qualid  ::=  global constants/variables (definitions, lemmas, theorems, etc.)

/* Numerals */
numeral ::=  num[.num][exp[sign]num]
int     ::=  [-]num
num     ::=  digit ... digit
digit   ::=  0..9
exp     ::=  e | E
sign    ::=  + | -

/* Terms */
term  ::=  forall binders , term
		 | fun binders => term
		 | fix fix_bodies
		 | cofix cofix_bodies
		 | let ident [binders] [: term] := term in term
		 | let fix fix_body in term
		 | let cofix cofix_body in term
		 | let ( [name , ... , name] ) [dep_ret_type] ::= term in term
		 | let ' pattern [in term] := term [return_type] in term
		 | if term [dep_ret_type] then term else term
		 | term : term
		 | term <: term
		 | term :>
		 | term -> term
		 | term arg ... arg   
		 | @ qualid [term ... term]
		 | term % ident      
		 | match match_iterm , ... , match_iterm [return_type] with
		 	[[|]] equation | ... | equation ] end    
		 | qualid
		 | sort
		 | num

arg  ::=  term
		| ( ident := term )

binders ::=  binder ... binder

binder  ::=  name
		   | ( name ... name : term ) /* This one is not used */
		   | ( name [: term] := term )
		   | ' pattern

name  ::=  ident | _

qualid ::=  ident | qualid field

sort  ::=  SProp | Prop | Set | Type

fix_bodies  ::=  fix_body
			   | fix_body with fix_body with ... with fix_body for ident

cofix_bodies  ::=  cofix_body
				 | cofix_body with cofix_body with ... with cofix_body for ident

fix_body  ::=  ident binders [annotation] [: term] := term

cofix_body  ::=  ident [binders] [: term] := term

annotation  ::=  { struct ident }

match_item  ::=  term [as name] [in qualid [pattern ... pattern]]

dep_ret_type  ::=  [as name] return_type

return_type  ::=  return term

equation  ::=  mult_pattern | ... | mult_pattern => term

mult_pattern  ::=  pattern , ... , pattern

pattern  ::=  qualid pattern ... pattern
			| @ qualid pattern ... pattern
			| pattern as ident
			| pattern % ident
			| qualid
			| _ 
			| num
			| ( pattern | ... | pattern )

/* The Vernacular */
decorated-sentence  ::=  [ decoration ... decoration ] sentence

sentence  ::=  assumption 
			|  definition
			| inductive
			| fixpoint
			| assertion proof
			
assumption  ::=  assumption_keyword assums.

assumption_keyword  ::=  Axopm 
					  | Conjecture	
					  | Parameter	
					  | Parameters
					  | Variable
					  | Variables
					  | Hypothesis
					  | Hypotheses
					  	
assums  ::=  ident ... ident : term
		   | ( ident ... ident : term ) ... ( ident ... ident : term )					
		   
definition  ::=  [Local] Definition ident [binders] [: term] := term .		   
		       | Let ident [binders] [: term] := term .

inductive  ::=  Inductive ind_body with ... with ind_body .
			  | CoInductive ind_body with ... with ind_body .
			  
ind_body  ::=  ident [binders] : term := 
				[[|]] ident [binders] [:term] | ... | ident [binders] [:term]]			  
fixpoint  ::=  Fixpoint fix_body with ... with fix_body .
			 | CoFixpoint cofix_body with ... with cofix_body .

assertion  ::=  assertion_keyword ident [binders] : term .

assertion_keyword  ::=  Theorem | Lemma
					  | Remark | Fact
					  | Corollary | Property | Proposition
					  | Definition | Example

proof  ::=  Proof . ... Qed .
		  | Proof . ... Defined .
		  | Proof. ... Admitted .

decoration  ::=  #[ attributes ]

attributes  ::=  [attribute, ... , attribute]

attribute  ::=  ident
			  | ident = string
			  | ident ( attributes )

\end{grm}


\bibliography{references}{}
\bibliographystyle{abbrv}

\end{document}
