\documentclass[a4paper,11pt]{article}

\usepackage{hyperref}
\usepackage{proof}
\usepackage{amsmath}
\usepackage[dvipsnames]{xcolor}
\usepackage{listings}

\usepackage{Coq}
\usepackage{SML}

\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommand{\giselle}[1]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum]{G: #1}}

\title{Translation of SML programs into Coq programs}
\date{}

\begin{document}
\maketitle

The goal of this document is to define formally the translation of SML programs,
represented by their abstract syntax tree (AST) into Coq programs, represented
by Gallina's AST. Before defining the translation, we specify the two ASTs in
question.
\giselle{TODO: better introduction, mention the tools we used and motivation.}

% Testing environments:
% 
% \begin{sml}
% datatype 'a tree = Empty
%                  | Node of 'a tree * 'a * 'a tree
% \end{sml}
% 
% \begin{coq}
% Definition g y := 
%   match (cons 1 nil) with
%     | (x :: l) => x + y
%     | _ => patternFailure
%   end.
% \end{coq}

\section{HaMLet}

HaMLet~\cite{hamlet} is an SML implementation whose goal is to be an accurate
implementation of the language definition~\cite{smldef}, and a platform for
experimentation. There are two main reasons why we chose it for this work. First
of all, it is faithful to SML's definition, and all bugs and ``grey areas'' and
well documented. Secondly, it is easy to access various steps of the compilation
process. Particularly, the abstract syntax tree from the elaboration phase was
readily available.

In order to have a translation as precise as possible, we needed a few
modifications in HaMLet. All changes were related to derived
forms.\giselle{check if this is still the case at the end.}
Derived forms are SML expressions that can be replaced by equivalent forms
during parsing, resulting in SML parse trees that are formed by only a subset of
the constructs in syntax trees. For example, boolean operators can be replaced by
the equivalent \smle{if ... then ... else}:

\begin{center}
\begin{tabular}{rcl}
{\smle|$e_1$ orelse $e_2$|}  & $\Rightarrow$ & {\smle|if $e_1$ then true else $e_2$|} \\
{\smle|$e_1$ andalso $e_2$|} & $\Rightarrow$ & {\smle|if $e_1$ then $e_2$ else false|}
\end{tabular}
\end{center}

HaMLet translates the derived forms as specified in SML's definition.
Translating this subset of SML's syntax to Coq is correct -- semantically
speaking -- however, the resulting Coq code will look very different: an
\smle{orelse} expression will be translated to an \coqe{if...then...else}
expression. Therefore, we decided to keep the original grammatical form and
translate that to Gallina.\giselle{explain the changes in more detail (see
googledoc)}

Even though the translation is done on the abstract syntax tree with the derived
forms, we still need to make sure that the code type checks and runs.
Additionally, the elaboration phase provides crucial information for the
translation, such as non-exhaustive match warnings. These two phases do not
consider the derived forms. This problem is solved by one of two approaches,
depending on the construct: (1) the derived form is replaced by the equivalent
form, and we interpret any needed information in the context of the derived
form; or (2) we implement an extra case for the derived form when it is
straighforward.

% all modifications are sound.

\section{SML's abstract syntax tree}


\section{Gallina's abstract syntax tree}

\bibliography{references}{}
\bibliographystyle{abbrv}

\end{document}
