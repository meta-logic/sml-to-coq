\documentclass[a4paper,11pt]{article}

\usepackage{hyperref}
\usepackage{proof}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[dvipsnames]{xcolor}

\usepackage{tabularx}
\usepackage{mathpartir}

\usepackage{amsthm}
\newtheorem{theorem}{Theorem}

\usepackage{listings}

\usepackage{Coq}
\usepackage{SML}
% For grammars
\lstdefinelanguage{grammar}{
  basicstyle=\footnotesize\ttfamily,
  %
  captionpos=b,
  % 
  tabsize=2,
  %
  columns=fixed,
  %
  breaklines=true,
  %
  frame=l,
  %
  morecomment=[s]{/*}{*/},
  %
  stringstyle=\color{black},
  %
  identifierstyle=\ttfamily,
  %
  otherkeywords= {=>, ;},
  %
  morekeywords= {
    EQUAL, GREATER, LESS, NONE, SOME, 
    abstraction, abstype, and, andalso, 
    array, as, before, bool, case, char, 
    datatype, do, else, end, eqtype, 
    exception, exn, false, fn, fun, 
    functor, handle, if, in, include, 
    infix, infixr, int, let, list, local, 
    nil, nonfix, not, o, of, op, open, 
    option, orelse, overload, print, 
    raise, real, rec, ref, sharing, sig, 
    signature, string, struct, structure, 
    substring, then, true, type, unit, val, 
    vector, where, while, with, withtype, word
  },
  %
  keywordstyle=\ttfamily\color{red},
  %
  commentstyle=\ttfamily\color{gray},
  % Spaces are not displayed as a special character
  showstringspaces=false,
  %
  mathescape=true,
  %
  escapeinside={!}{!}
}
\lstnewenvironment{grm}{\lstset{language=grammar}}{}

%% This makes lstlistings work inside math environment
\usepackage{letltxmacro}
\newcommand*{\SavedLstInline}{}
\LetLtxMacro\SavedLstInline\lstinline
\DeclareRobustCommand*{\lstinline}{%
  \ifmmode
    \let\SavedBGroup\bgroup
    \def\bgroup{%
      \let\bgroup\SavedBGroup
      \hbox\bgroup
    }%
  \fi
  \SavedLstInline
}

\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommand{\giselle}[1]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum]{G: #1}}


\newcommand{\laila}[1]{\todo[linecolor=Green,backgroundcolor=Green!40,bordercolor=Green]{L: #1}}

% Macros for translation
\newcommand\stog{\boldsymbol{\Longrightarrow}}
\newcommand\stogtycon{\;\stog_\mathtt{TyCon}\;}
\newcommand\stogtyvar{\;\stog_\mathtt{TyVar}\;}
\newcommand\stogatexp{\;\stog_\mathtt{AtExp}\;}
\newcommand\stogexp{\;\stog_\mathtt{Exp}\;}
\newcommand\stogmatch{\;\stog_\mathtt{Match}\;}
\newcommand\stogdec{\;\stog_\mathtt{Dec}\;}
\newcommand\stogvalbind{\;\stog_\mathtt{ValBind}\;}
\newcommand\stogtybind{\;\stog_\mathtt{TyBind}\;}
\newcommand\stogdatbind{\;\stog_\mathtt{DatBind}\;}
\newcommand\stogconbind{\;\stog_\mathtt{ConBind}\;}
\newcommand\stogexbind{\;\stog_\mathtt{ExBind}\;}
\newcommand\stogatpat{\;\stog_\mathtt{AtPat}\;}
\newcommand\stogpatrow{\;\stog_\mathtt{PatRow}\;}
\newcommand\stogpat{\;\stog_\mathtt{Pat}\;}
\newcommand\stogty{\;\stog_\mathtt{Ty}\;}
\newcommand\stoglab{\;\stog_\mathtt{Lab}\;}
\newcommand\stogscon{\;\stog_\mathtt{SCon}\;}
\newcommand\stogvid{\;\stog_\mathtt{VId}\;}

\newcommand{\tbd}{\colorbox{yellow}{\textbf{TBD}}}

\newcounter{infercount}
\setcounter{infercount}{1}
\newcommand{\infern}[3]{\infer[{\mathsf{#3}}_{\arabic{infercount}}\stepcounter{infercount}]{#2}{#1}}

\newcommand\derived[2]{\smle{#1}&\smle{#2}}

\title{Translation of SML programs into Coq programs}
\date{}

\begin{document}
\maketitle

The goal of this document is to define formally the translation of SML programs,
represented by their abstract syntax tree (AST) into Coq programs, represented
by Gallina's AST. Before defining the translation, we specify the two ASTs in
question.
\giselle{TODO: better introduction, mention the tools we used and motivation.}

% Testing environments:
% 
% \begin{sml}
% datatype 'a tree = Empty
%                  | Node of 'a tree * 'a * 'a tree
% \end{sml}
% 
% \begin{coq}
% Definition g y := 
%   match (cons 1 nil) with
%     | (x :: l) => x + y
%     | _ => patternFailure
%   end.
% \end{coq}

\section{HaMLet}

HaMLet~\cite{hamlet} is an SML implementation whose goal is to be an accurate
implementation of the language definition~\cite{smldef}, and a platform for
experimentation. There are two main reasons why we chose it for this work. First
of all, it is faithful to SML's definition, and all bugs and ``grey areas'' and
well documented. Secondly, it is easy to access various steps of the compilation
process. Particularly, the abstract syntax tree from the elaboration phase was
readily available.

In order to have a translation as precise as possible, we needed a few
modifications in HaMLet. All changes were related to derived
forms.\giselle{check if this is still the case at the end.}
Derived forms are SML expressions that can be replaced by equivalent forms
during parsing, resulting in SML parse trees that are formed by only a subset of
the constructs in syntax trees. For example, boolean operators can be replaced by
the equivalent \smle{if ... then ... else}:

\begin{center}
\begin{tabular}{rcl}
{\smle|$e_1$ orelse $e_2$|}  & $\Rightarrow$ & {\smle|if $e_1$ then true else $e_2$|} \\
{\smle|$e_1$ andalso $e_2$|} & $\Rightarrow$ & {\smle|if $e_1$ then $e_2$ else false|}
\end{tabular}
\end{center}

HaMLet translates the derived forms as specified in SML's definition.
Translating this subset of SML's syntax to Coq is correct -- semantically
speaking -- however, the resulting Coq code will look very different: an
\smle{orelse} expression will be translated into an \coqe{if...then...else}
expression. Therefore, we decided to keep the original grammatical form and
translate that to Gallina.

Even though the translation is done on the abstract syntax tree with the derived
forms, we still need to make sure that the code type checks and runs.
Additionally, the elaboration phase provides crucial information for the
translation, such as non-exhaustive match warnings. These two phases do not
consider the derived forms. This problem is solved by one of two approaches,
depending on the construct: (1) the derived form is replaced by the equivalent
form, and we interpret any needed information in the context of the derived
form; or (2) we implement an extra case for the derived form when it is
straighforward.

% all modifications are sound.

\section{Changes in HaMLet}

The following tables are taken from SML's documentation but in our case, we
restore the original forms (left column) from their equivalent forms (right
column). The reason we do this step is because (while the semantics do not
change) the code looks very foreign after derivation (and hence does the
translation).

Note that some derivations are not restored because the output doesn't affect
the translation (see discussion on $fvalbind$ below). 

\newcommand\changedto{\Longrightarrow}

\noindent
\textbf{Expressions}\\
\begin{tabularx}{1.0\textwidth} { 
  | >{\raggedright\arraybackslash}X
  | >{\raggedright\arraybackslash}X | }
 \hline
 Derived Form & Equivalent Form \\
 \hline
 \derived{()}{\{ \}}\\
 \hline
 \derived{(exp_1, ... , exp_n)}{\{1 = exp_1, ... , n = exp_n\}}\\
 \hline
 \derived{[exp_1, ... , exp_n]}{exp_1 :: ... :: exp_n :: nil}\\
 \hline
 \derived{case exp of match}{(fn match) (exp)}\\
 \hline
 \derived{if exp_1 then exp_2 else exp_3}{case exp_1 of true => exp_2 \ \ \ \ \ \ \ \ \  | false => exp_3}
 \\
 \hline
 \derived{exp_1 andalso exp_2}{if exp_1 then exp_2 else false}\\
 \hline
 \derived{exp_1 orelse exp_2}{if exp_1 then true else exp_2}\\
\hline
\end{tabularx}\\ \\

\noindent
\textbf{Patterns}\\
\begin{tabularx}{1.0\textwidth} { 
  | >{\raggedright\arraybackslash}X
  | >{\raggedright\arraybackslash}X | }
 \hline
 Derived Form & Equivalent Form \\
 \hline
 \derived{()}{\{ \}}\\
 \hline
 \derived{(pat_1, ... , pat_n)}{\{1 = pat_1, ... , n = pat_n\}}\\
 \hline
 \derived{[pat_1, ... , pat_n]}{pat_1 :: ... :: pat_n :: nil}\\
 \hline
\end{tabularx}\\ \\

\noindent
\textbf{Types}\\
\begin{tabularx}{1.0\textwidth} { 
  | >{\raggedright\arraybackslash}X
  | >{\raggedright\arraybackslash}X | }
 \hline
 Derived Form & Equivalent Form \\
 \hline
 \derived{ty_1 * ... * ty_n}{\{1 : ty_1, ..., n : ty_n\}}
\\
 \hline
\end{tabularx}

\subsection{Useful Derived Forms}

The derivation of function-value bindings $fvalbind$ is the one case where we
need to keep the derivation because it simplifies translation. The syntax in
Gallina doesn't allow for pattern-matching on function arguments, so the
derivation (which ) solves the problem.

\noindent
\begin{tabularx}{1.0\textwidth} { 
  | >{\raggedright\arraybackslash}X
  | >{\raggedright\arraybackslash}X | }
 \hline
 Derived Form & Equivalent Form \\
\hline
 &\smle{[op] vid = fn vid_1 => ... => fn vid_n =>}\\
 &\smle{case (vid_1, ..., vid_n) of}\\ 
 \derived
 {[op] vid atpat_11 ... atpat_1n [:ty] = exp_1}
 {(atpat_11, ..., atpat_1n) => exp_1 [:ty]}\\
 \derived
 {| [op] vid atpat_21 ... atpat_2n [:ty] = exp_2}
 {| (atpat_21, ..., atpat_2n) => exp_2 [:ty]} 
  \\ 
 \vdots & \vdots
 \\ 
 \derived
 {| [op] atpat_m1 ... atpat_mn [:ty] = exp_m}
 {| (atpat_m1, ..., atpat_mn) => exp_m [:ty]}
 \\  
 $\langle \texttt{and } fvalbind \rangle$ &
  $\langle \texttt{and } fvalbind \rangle $ \\
 \hline 
\end{tabularx}

\section{Changes in Gallina}

\section{Translation}

In this section we define the translation from our modified HaMLet AST to our
also modified Gallina's AST. We will use a derivation system with the judgment
$S \stog G$, where $S$ and $G$ are SML and Gallina ASTs respectively.

The sections below are in the same order as SML's AST definition in the
appendix.

\subsection{Record Labels}

Record labels have no restrictions apart from starting with an
alphanumeric character, or \_.

\[
\infer[\mathsf{Lab}]{\smle{l} \stoglab \coqe{l}}{}
\]
\giselle{Are there allowed labels in SML that need special care?}

\subsection{Type Constructors}

Most type constructors are translated \emph{as is}, using the
$\mathsf{TyCon}$ rule.  However, some built-in type constructors need
to be translated to the corresponding types in Coq.

\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{TyCon}]{\smle{tycon} \stogtycon \coqe{tycon}}{
  \smle{tycon} \notin \{ \smle{int},\smle{real},\\
  \smle{char},\smle{order},\smle{unit} \}
}
&
\infer[\mathsf{TyCon}_{\smles{int}}]{\smle{int} \stogtycon \coqe{Z}}{}
\\
\infer[\mathsf{TyCon}_{\smles{real}}]{\smle{real} \stogtycon \coqe{float}}{}
&
\infer[\mathsf{TyCon}_{\smles{char}}]{\smle{char} \stogtycon \coqe{ascii}}{}
\\
\infer[\mathsf{TyCon}_{\smles{order}}]{\smle{order} \stogtycon \coqe{comparison}}{}
&
\infer[\mathsf{TyCon}_{\smles{unit}}]{\smle{unit} \stogtycon \coqe{tt}}{}
\\
\end{array}
\]

\subsection{Type Variables}

Type variables in SML are prefixed by \smle{'}, but this is illegal in
Coq. Therefore, we prefix type variables in Coq by \coqe{_}.

\[
\infer[\mathsf{TyVar}]{\smle{'tyvar} \stogtyvar \coqe{_tyvar}}{
  \smle{tyvar} \text{ is alphanumeric}
}
\]

\subsection{Type Expressions}

\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{c}
\infer[\mathsf{TyExp}_{\smles{TyVar}}]{\smle{t} \stogty \coqe{t'}}{
  \smle{t} \stogtyvar \coqe{t'}
}
\end{array}
\]
\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{TyExp}_{()}]{\smle!( t )! \stogty \coqe!( t' )!}{
  \smle{t} \stogty \coqe{t'}
}
&
\infer[\mathsf{TyExp}_{\smles{->}}]{t_1 \smle{->} t_2 \stogty t'_1 \coqe{->} t'_2}{
  t_1 \stogty t'_1
  &
  t_2 \stogty t'_2}
\end{array}
\]
\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{c}
\infer[\mathsf{TyExp}_{\smles{TyCon}}]{\smle!$t_1, \dots, t_n\;$ con! \stogty \coqe!con' $\;t'_1 \dots t'_n$!}{
  \smle{con} \stogtycon \coqe{con'}
  &
  t_i \stogty t'_i & \forall i. 1 \leq i \leq n, n \geq 0
}
\\
\infer[\mathsf{TyExp}_{\smles{*}}]{\smle!($t_1$ * $t_2$ * ... * $t_n$)! \stogty 
                      \coqe!($t'_1$ * $t'_2$ * ... * $t'_n$)\%type!}
{
  t_i \stogty t'_i & \forall i. 1 \leq i \leq n, n \geq 1
}
\\
\infer[\mathsf{TyExp}_{rec}]{\smle!\{ $l_1 : t_1, \dots, l_n : t_n$ \}! \stogty \smle!\{ $l'_1 : t'_1; \dots; l'_n : t'_n$ \}!}{
  l_i \stoglab l'_i
  &
  t_i \stogty t'_i
  &
  \forall i. 1 \leq i \leq n, n \geq 1
}
\end{array}
\]
\giselle{G: Why is the \%\coqes{type} needed in the translation of tuple types?}

Notice that type constructors may take 0 arguments 
(rule $\mathsf{TyExp}_{\smles{TyCon}}$), but tuple types must consist of 
at least one type (rule $\mathsf{TyExp}_{\smles{*}}$).

\subsection{Type Bindings}

Type bindings are translated into Coq definitions. In case they are 
mutually recursive, we need to use \coqe{Fixpoint}, thus the
\coqe{end with} in rule $\mathsf{TyBind}$.

\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{c}
\infer[\mathsf{TyBind}_0]{\smle!$v_1, \dots, v_n$ con = t! \stogtybind \coqe!con' $v'_1 \dots v'_n$ = t'!}{
  \smle{con} \stogtycon \coqe{con'}
  &
  \smle{t} \stogty \coqe{t'}
  &
  v_i \stogtyvar v'_i \;\; \forall i. 1 \leq i \leq n, n \geq 0
}
\\
\infer[\mathsf{TyBind}]{\smle{b and tb} \stogtybind \coqe{b' end with tb'}}{
  \smle{b} \stogtybind \coqe{b'}
  &
  \smle{tb} \stogtybind \coqe{tb'}
}
\end{array}
\]

\subsection{Special constants}

Special constants are value inhabitants of \smle{int}, \smle{real}, 
\smle{word}, \smle{string}, and \smle{char}. Note that:

\begin{itemize}
  \item The notation \# for characters in Coq is defined in the 
  library \texttt{charSml.v} to look exactly like SML characters.

  \item Real constants are translated using the explicit type
  annotation \%\coqe{float}. This could be avoided by using 
  \coqe{float_scope}, however opening this scope will make Coq 
  interpret any number without dot notation, such as \coqe{5}, 
  as a floating point number instead of an integer.
  In SML \smle{5} is \emph{always} an integer, and \smle{5.0} is
  a floating point number. In order to keep the original types,
  our solution is \emph{not} to open \coqe{float_scope} and explicit
  annotate every floating point number.

  \item Negative numbers are indicated by $\sim$ in SML and by 
  \coqe{-} in Coq.

\end{itemize}

\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{SCon}_{\smles{int}}]{\smle{n} \stogscon \coqe{n}}{}
&
\infer[\mathsf{SCon}_{\smles{int}_{-}}]{\smle!$\sim$ n! \stogscon \coqe{- n}}{}
\\
\infer[\mathsf{SCon}_{\smles{real}}]{\smle{r} \stogscon \coqe{r\%float}}{}
&
\infer[\mathsf{SCon}_{\smles{real}_{-}}]{\smle!$\sim$ r! \stogscon \coqe{(- r)\%float}}{}
\\
\infer[\mathsf{SCon}_{\smles{string}}]{\smle{s} \stogscon \coqe{s}}{}
&
\infer[\mathsf{SCon}_{\smles{char}}]{\smle{#c} \stogscon \coqe{#c}}{}
\\
\infer[\mathsf{SCon}_{\smles{word}}]{\smle{w} \stogscon \tbd}{}
&
\end{array}
\]


\subsection{Value Identifiers}

Most value identifiers are translated \emph{as is} from SML to Coq, 
however there are a few special cases that need to be handled
exceptionally because the corresponding identifier in Coq is
different. This is mostly due to different type constructors or
functions.

\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{VId}]{\smle{id} \stogvid \coqe{id}}{
  \smle{id} \notin \{\smle{SOME}, \smle{NONE},\\
  \smle{LESS}, \smle{EQUAL}, \smle{GREATER} \}
}
&
\infer[\mathsf{VId}_{\smles{EQUAL}}]{\smle{EQUAL} \stogvid \coqe{Eq}}{}
\\
\infer[\mathsf{VId}_{\smles{LESS}}]{\smle{LESS} \stogvid \coqe{Lt}}{}
&
\infer[\mathsf{VId}_{\smles{GREATER}}]{\smle{GREATER} \stogvid \coqe{Gt}}{}
\\
\infer[\mathsf{VId}_{\smles{SOME}}]{\smle{SOME} \stogvid \coqe{Some}}{}
&
\infer[\mathsf{VId}_{\smles{List.exists}}]{\smle{List.exists} \stogvid \coqe{List.existsb}}{}
\\
\infer[\mathsf{VId}_{\smles{NONE}}]{\smle{NONE} \stogvid \coqe{None}}{}
&
\infer[\mathsf{VId}_{\smles{ListPair.exists}}]{\smle{ListPair.exists} \stogvid \coqe{ListPair.existsb}}{}
\end{array}
\]
\giselle{Are there other identifiers in SML that need special care?
What do we do with Coq keywords? Are identifiers using dot considered as VId?}

% A more extensive explanation on why we did not change SML's AST and
% went with the special case instead. Leaving it here for posterity.
%
% \begin{paragraph}{\smle{option} expressions}
% In SML, the type \smle{option}, with constructors \smle{SOME} and \smle{NONE},
% is not built-in. Therefore, the keywords \smle{SOME} and \smle{NONE} are
% \lstinline{VId}s and would be translated as is (by rule $\mathsf{AtExp}_2$).
% This is problematic because Coq's option type constructors are \coqe{Some} and
% \coqe{None} (i.e. in a different capitalization). One way to solve this is to
% add special constructors for option types to SML's AST, much like we did for
% tuples and lists. However, unlike tuples and lists, option types are not
% recognized by the parser as special entities. This means we would need deeper
% changes in HaMLet to create dedicated constructors for options. To avoid these
% more intrusive modifications, we instead use rule $\mathsf{AtExp}_2$ with a
% \emph{side condition}: if \smle{e} is \smle{SOME} or \smle{NONE}, then it is
% translated to \coqe{Some} or \coqe{None}, respectively.
% \end{paragraph}


\subsection{Atomic Expressions}

\setlength{\jot}{0.5pt} 
\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{AtExp}_{\smles{SCon}}]{\smle{c} \stogatexp \coqe{c'}}{
  \smle{c} \stogscon \coqe{c'}
}
&
\infer[\mathsf{AtExp}_{\smles{VId}}]{\smle{id} \stogatexp \coqe{id'}}{
  \smle{id} \stogvid \coqe{id'}
}
\\
\infer[\mathsf{AtExp}_{\smles{()}}]{\smle{()} \stogatexp \coqe{()}}{}
&
\infer[\mathsf{AtExp}_{\smles{(e)}}]{\smle{(e)} \stogatexp \coqe{(e')}}{
  \smle{e} \stogexp \coqe{e'}
}
\end{array}
\]
\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{c}
\infer[\mathsf{AtExp}_{\smles{let}_1}]{\smle{let d in e end} \stogatexp \coqe{let d' in t}}{
  \smle{e} \stogexp \coqe{t} & \smle{d}\stogdec \coqe{Definition d'}
}
\\
\infer[\mathsf{AtExp}_{\smles{let}_n}]{\smle{let d in e end} \stogatexp \coqe!let d$_1$ in ... in let d$_n$ in t!}{
  \begin{gathered}
  \smle{e} \stogexp \coqe{t} \quad \smle{d}\stogdec \coqe{sentence}_1 ... \coqe{sentence}_n \\ 
  \coqe{sentence}_1 \equiv \coqe{Definition d}_1 \quad ... \quad \coqe{sentence}_n \equiv \coqe{Definition d}_n 
  \end{gathered}
}
\\
\infer[\mathsf{AtExp}_{tpl}]{\smle!($e_1, \dots, e_n$)! \stogatexp \coqe!($e'_1, \dots,e'_n$)!}{
  e_i \stogexp e'_i 
  & 
  \forall i. 1 \leq i \leq n, n \geq 1
}
\\
\infer[\mathsf{AtExp}_{lst}]{\smle![$e_1, \dots, e_n$]! \stogatexp \coqe![$e'_1; \dots;e'_n$]!}{
  e_i \stogexp e'_i 
  & 
  \forall i. 1 \leq i \leq n, n \geq 0
}
\\
\infer[\mathsf{AtExp}_{\smles{op}}]{\smle{op id} \stogatexp \tbd}{}
\\
\infer[\mathsf{AtExp}_{rec}]{\smle!\{$l_1 : t_1, \dots, l_n : t_n$\}! \stogatexp \tbd}{}
\end{array}
\]
\giselle{G: add translations for op VId and Records.}

Obs: the declarations \texttt{d} inside let-expressions are translated as
``top-level'' Coq declarations (that is why the \coqe{Definition} keyword is
there). The translation \texttt{d'} or \texttt{d}$_i$ is extracted from this
definition.


\subsection{Expressions}

\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{Exp}_{\smles{AtExp}}]{\smle{e} \stogexp \coqe{e'}}{
  \smle{e} \stogatexp \coqe{e'}
}
&
\infer[\mathsf{Exp}_{app}]{\smle!e$_1$ e$_2$! \stogexp \coqe!e$_1$' e$_2$'!}{
  \smle!e$_1$! \stogexp \coqe!e$_1$'!
  &
  \smle!e$_2$! \stogatexp \coqe!e$_2$'!
}
\\
\infer[\mathsf{Exp}_{ty}]{\smle{e : t} \stogexp \coqe{e' : t'}}{
  \smle{e} \stogexp \coqe{e'}
  &
  \smle{t} \stogty \coqe{t'}
}
&
\infer[\mathsf{Exp}_{\smles{fn}}]{\smle{fn m} \stogexp \tbd}{
  \smle{m} \stogmatch \coqe{m'}
}
\\
\infer[\mathsf{Exp}_{\smles{handle}}]{\smle{e handle m} \stogexp \tbd}{
  \smle{e} \stogexp \coqe{e'}
  &
  \smle{m} \stogmatch \coqe{m'}
}
&
\infer[\mathsf{Exp}_{\smles{raise}}]{\smle{raise e} \stogexp \tbd}{
  \smle{e} \stogexp \coqe{e'}
}
\end{array}
\]
\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{c}
\infer[\mathsf{Exp}_{\smles{case}}]{\smle{case e of m} \stogexp \coqe{match e' with m' end}}{
  \smle{e} \stogexp \coqe{e'}
  &
  \smle{m} \stogmatch \coqe{m'}
}
\\
\infer[\mathsf{Exp}_{\smles{if}}]{\smle!if e$_1$ then e$_2$ else e$_3$! \stogexp 
                    \coqe!if e$_1$' then e$_2$' else e$_3$'!}{
  \smle!e$_i$! \stogexp \coqe!e$_i$'!
  &
  \forall i \in \{1,2,3\}
}
\end{array}
\]
\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{Exp}_{and}]{\smle!e$_1$ andalso e$_2$! \stogexp 
                     \coqe!e$_1$' \&\& e$_2$'!}{
  \smle!e$_1$! \stogexp \coqe!e$_1$'!
  &
  \smle!e$_2$! \stogexp \coqe!e$_2$'!
}
&
\infer[\mathsf{Exp}_{or}]{\smle!e$_1$ orelse e$_2$! \stogexp 
                     \coqe!e$_1$' || e$_2$'!}{
  \smle!e$_1$! \stogexp \coqe!e$_1$'!
  &
  \smle!e$_2$! \stogexp \coqe!e$_2$'!
}
\\
\end{array}
\]

\begin{paragraph}{SML booleans}
The translation of \smle{andalso} and \smle{orelse} requires notations defined
in Coq's \coqe{Bool} library.
\end{paragraph}


\subsection{Pattern Matching}

\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{c}
\infer[\mathsf{Match}_0]{\smle{p => e} \stogmatch \coqe{p' => e'}}{
  \smle{p} \stogpat \coqe{p'}
  &
  \smle{e} \stogexp \coqe{e'}
}
\\
\infer[\mathsf{Match}]{\smle{p => e | M} \stogmatch \coqe{p' => e' | M'}}{
  \smle{p} \stogpat \coqe{p'}
  &
  \smle{e} \stogexp \coqe{e'}
  &
  \smle{M} \stogmatch {M'}
}

\end{array}
\]

\subsection{Atomic Patterns}

\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{AtPat}_{\_}]{\smle{_} \stogatpat \coqe{_}}{}
&
\infer[\mathsf{AtPat}_{\smles{SCon}}]{\smle{c} \stogatpat \coqe{c'}}{
  \smle{c} \stogscon \coqe{c'}
}
\\
\infer[\mathsf{AtPat}_{\smles{VId}}]{\smle{id} \stogatpat \coqe{id'}}{
  \smle{id} \stogvid \coqe{id'}
}
&
\infer[\mathsf{AtPat}_{\smles{op}}]{\smle{op id} \stogatpat \tbd}{}
\\
\infer[\mathsf{AtPat}_{\smles{(p)}}]{\smle{(p)} \stogatpat \coqe{(p')}}{
  \smle{p} \stogpat \coqe{p'}
}
&
\infer[\mathsf{AtPat}_{\smles{()}}]{\smle{()} \stogatpat \coqe{()}}{}
\end{array}
\]
\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{c}
\infer[\mathsf{AtPat}_{tpl}]{\smle!($p_1, \dots, p_n$)! \stogatpat \coqe!($p'_1, \dots,p'_n$)!}{
  p_i \stogpat p'_i 
  & 
  \forall i. 1 \leq i \leq n, n \geq 1
}
\\
\infer[\mathsf{AtPat}_{lst}]{\smle![$p_1, \dots, p_n$]! \stogatpat \coqe![$p'_1; \dots;p'_n$]!}{
  p_i \stogpat p'_i 
  & 
  \forall i. 1 \leq i \leq n, n \geq 0
}
\\
\infer[\mathsf{AtPat}_{rec}]{\smle{\{ recpat \}} \stogatpat \coqe{\{ recpat' \}}}{
  \smle{recpat} \stogpatrow \coqe{recpat'}
}
\end{array}
\]

\subsection{Record Patterns}

TODO

\subsection{Patterns}

TODO


\subsection{Declarations}

TODO

% \[
% \arraycolsep=15pt\def\arraystretch{3}
% \begin{array}{cc}
% \infer[\mathsf{Val}]{\smle{} \stogdec \coqe{}}{
% }
% &
% \infer[\mathsf{Type}]{}{
% }
% \\
% \infer[\mathsf{DaTyp}]{\smle{} \stogdec \coqe{}}{
% }
% &
% \infer[\mathsf{DaTypAlias}]{}{
% }
% \\
% \infer[\mathsf{AbsType}]{\smle{} \stogdec \coqe{}}{
% }
% &
% \infer[\mathsf{ExnDec}]{}{
% }
% \\
% \infer[\mathsf{Local}]{\smle{} \stogdec \coqe{}}{
% }
% &
% \infer[\mathsf{Open}]{}{
% }
% \\
% \infer[\mathsf{EmpDec}]{\smle{} \stogdec \coqe{}}{
% }
% &
% \infer[\mathsf{SeqDec}]{}{
% }
% \end{array}
% \]

\subsection{Value Bindings}

TODO

\subsection{Data Bindings}

TODO

\subsection{Constructor Bindings}

TODO

\subsection{Exception Bindings}

TODO

\section{Simulation}

\giselle{This is *very* preliminary. Just some ideas to see where it goes.}

Let $\rightsquigarrow_s$ and $\rightsquigarrow_g$ denote the evaluation
semantics of SML and Gallina, respectively. Then a simulation theorem would look
like this:

\begin{theorem}
Let $S$ be an SML expression(?) such that $S \stog G$, and 
$S \rightsquigarrow_s S'$. Then, there exists $G'$ such that
$S' \stog G'$ and $G \rightsquigarrow_g G'$.
\end{theorem}

Relation $\rightsquigarrow_g$ is probably the conversion rules of calculus of
constructions, defined at
\url{https://coq.inria.fr/refman/language/cic.html#conversion-rules}.

Relation $\rightsquigarrow_s$ is probably SML's dynamic semantics, defined in
section 6.7 (page 60) in \url{https://smlfamily.github.io/sml97-defn.pdf}.

\appendix

\section{SML's abstract syntax tree}

The datatypes used for SML's abstract syntax tree is defined in the file
\texttt{hamlet/syntax/SyntaxCoreFn.sml}. It is reproduced here in a grammar
format, where the same datatype names are used, and SML keywords are explicit.

Elements in $\langle\rangle$ are optional.

% Constructors ending in X are Laila's additions
\begin{grm}
/* Special Constants */
SCon ::= /* integer, real, word, strings, 
            and character constants (e.g. 42) */

/* Type Constructors */
TyCon ::= /* allowed type constructors (int,tree,list,etc) */

/* Names and identifiers */
VId   ::= /* allowed value identifiers */
StrId ::= /* allowed structure identifiers */
Lab   ::= /* allowed record labels */
TyVar ::= /* allowed type variable names */

/* Type Expressions */
Ty ::= TyVar
     | { Lab : Ty, Lab : Ty, ..., Lab : Ty }
     | !$\langle$!Ty!$\rangle^*$! TyCon /* e.g. 'a, 'b Tree */
     | Ty -> Ty
     | (Ty)
     /* Added types */
     | (Ty * Ty * ... * Ty)

/* Atomic Expressions */
AtExp ::= SCon 
        | !$\langle$!op!$\rangle$! VId 
        | {Lab: Exp, Lab: Exp, ..., Lab: Exp} 
        | let Dec in Exp end 
        | (Exp) 
        /* Added expressions (records in hamlet) */
        | () 
        | (Exp, Exp, ..., Exp) 
        | [Exp, Exp, ..., Exp]

/* Expressions */
Exp ::= AtExp 
      | Exp AtExp 
      | Exp : Ty 
      | Exp handle Match
      | raise Exp 
      | fn Match
      /* Added expressions (derived forms) */
      | case Exp of Match 
      | if Exp then Exp else Exp
      | Exp andalso Exp 
      | Exp orelse Exp

/* Pattern matching */
Match ::= Pat => Exp !$\langle$!| Match!$\rangle$!

/* Declarations */
Dec ::= val !$\langle$!TyVar!$\rangle^*$! ValBind /* E.g. val 'a x = 5 */
      | type TypBind
      | datatype DatBind
      | datatype TyCon = datatype TyCon
      | abstype Datbind with Dec end
      | exception ExBind
      | local Dec in Dec end
      | open StrId ... StrId
      | !$\varepsilon$!
      | Dec ; Dec
      
/* Value binding */
ValBind ::= Pat = Exp !$\langle$!and ValBind!$\rangle$!
          | rec ValBind

/* Type binding */
TypBind ::= !$\langle$!TyVar!$\rangle^*$!  TyCon = Ty !$\langle$!and TypBind!$\rangle$!

/* Data binding */
DatBind ::= !$\langle$!TyVar!$\rangle^*$!  TyCon = ConBind !$\langle$!and DatBind!$\rangle$!

/* Constructor binding */
ConBind ::= !$\langle$!op!$\rangle$! VId !$\langle$!of Ty!$\rangle$! !$\langle$!| ConBind!$\rangle$!

/* Exception binding */
ExBind ::= !$\langle$!op!$\rangle$! VId !$\langle$!of Ty!$\rangle$! !$\langle$!and ExBind!$\rangle$!
         | !$\langle$!op!$\rangle$! VId = !$\langle$!VId!$\rangle$! !$\langle$!and ExBind!$\rangle$!

/* Atomic Patterns */
AtPat ::= _ 
        | SCon
        | !$\langle$!op!$\rangle$! VId 
        | { !$\langle$!PatRow!$\rangle$! }
        | ( Pat )
        /* Added patterns (translated to records originally) */
        | ()
        | (Pat, Pat, ...)
        | [Pat, Pat, ...]

/* Record Patterns */
PatRow ::= ... /* Wildcard for records */
         | Lab = Pat !$\langle$!, PatRow!$\rangle$!

/* Patterns */
Pat ::= AtPat
      | !$\langle$!op!$\rangle$! VId AtPat
      | Pat : Ty
      | !$\langle$!op!$\rangle$! VId !$\langle$!: Ty!$\rangle$! as pat
\end{grm}

\section{Gallina's abstract syntax tree}

This AST is slightly different from Gallina's grammar in Coq's reference manual
(see section ....).

An expression enclosed in square brackets [...] means at
most one occurrence of this expression (this corresponds to an optional
component). The notation "entry sep ... sep entry" stands for a non empty sequence
of expressions parsed by entry and separated by the literal "sep". Similarly,
the notation "entry ... entry" stands for a non empty sequence of expressions
parsed by the "entry" entry, without any separator between.


\begin{grm}


/* Identifiers */
ident ::= string

/* Terms */
term ::= forall binder ... binder , term
       | fun binder ... binder => term
       | fix fix_bodies
       | cofix cofix_bodies
       | let ident [binder ... binder] [: term] := term in term
       | let fix fix_body in term
       | let cofix cofix_body in term
       | let ( name , ... , name ) := term in term
       | let ' pattern [in term] := term in term
       | if term then term else term
       | term : term
       | term -> term
       | term arg ... arg   
       | @ ident [term ... term]
       | term % ident      
       | match match_iterm , ... , match_iterm with
               [ equation | ... | equation ] end    
       | ident
       | sort
       | num
       | _
       | ( term )
       | word
       | real
       | string
       | char
       | hex
       | ( term , ... , term )
       | term * ... * term
       | [ term , ... , term ] /* syntactic square brackets */
       
       
arg ::= term
      | ( ident := term )

binder ::= ( name [: term] ) 
         | ( name ... name [: term] := term ) /* probably can be omitted */
         | ' pattern

name ::= ident | _

sort ::= Prop | Set | Type

fix_bodies ::= fix_body with ... with fix_body for ident

cofix_bodies ::= cofix_body with ... with cofix_body for ident

fix_body ::= ident [binder ... binder] [annotation] [: term] := term

cofix_body ::= ident [binder ... binder] [: term] := term

annotation ::= { struct ident }

match_item ::= term 

dep_ret_type ::= [as name] return_type /* not used */

return_type ::= return term /* not used */

equation ::= pattern => term

pattern ::= ident pattern ... pattern
          | @ ident pattern ... pattern
          | pattern as ident
          | pattern % ident
          | qualid
          | _ 
          | num
          | ( pattern , ... , pattern )
          | [ pattern ; ... ; pattern ] /* syntactic square brackes */ 
          | ( pattern ) /* only present in intermediate translation steps */
			
				
/* The Vernacular */
sentence ::= definition
           | inductive
           | fixpoint
           | sentence ... sentence
           /* Gallina syntax extensions */
           | Record [ recBody , ... , recBody ]
					  	   
definition ::= [Local] Definition ident [binder ... binder] [: term] := term .		   
             | Let ident [binder ... binder] [: term] := term .

inductive ::= Inductive ind_body with ... with ind_body .
            | CoInductive ind_body with ... with ind_body .
			  
ind_body ::= ident  [binder ... binder] : term := clause | ... | clause

clause ::= ident [binder ... binder] [:term]
				
						  
fixpoint ::= Fixpoint fix_body with ... with fix_body .
           | CoFixpoint cofix_body with ... with cofix_body .
\end{grm}

Note that types \coqe{int}, \coqe{string}, \coqe{real}, \coqe{char}, and
\coqe{word} are defined in external libraries:\giselle{Some of these libraries
we need to implement/extend. Ammar is looking into this. Update this list as
this is developed.}

\begin{itemize}
  \item \coqe{int} is defined in \texttt{ZArith}.
  \item \coqe{string} is defined in \texttt{String}
  \item \coqe{real} is defined in \texttt{Reals}
  \item \coqe{char} is defined in (our own char lib?)
  \item \coqe{word} is defined in (our own word lib?)
\end{itemize}

\giselle{Reminder: Once all changes to the ASTs are stable, we should probably
argue how our modified ASTs are correct w.r.t. the orginal ones.}


\bibliography{references}{}
\bibliographystyle{abbrv}

\end{document}
