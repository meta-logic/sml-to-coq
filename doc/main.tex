\documentclass[a4paper,11pt]{article}

\usepackage{hyperref}
\usepackage{proof}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[dvipsnames]{xcolor}

\usepackage{tabularx}
\usepackage{mathpartir}

\usepackage{amsthm}
\newtheorem{theorem}{Theorem}

\usepackage[symbol]{footmisc}
\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\usepackage{listings}

\usepackage{Coq}
\usepackage{SML}
% For grammars
\lstdefinelanguage{grammar}{
  basicstyle=\footnotesize\ttfamily,
  %
  captionpos=b,
  % 
  tabsize=2,
  %
  columns=fixed,
  %
  breaklines=true,
  %
  frame=l,
  %
  morecomment=[s]{/*}{*/},
  %
  stringstyle=\color{black},
  %
  identifierstyle=\ttfamily,
  %
  otherkeywords= {=>, ;},
  %
  morekeywords= {
    EQUAL, GREATER, LESS, NONE, SOME, 
    abstraction, abstype, and, andalso, 
    array, as, before, bool, case, char, 
    datatype, do, else, end, eqtype, 
    exception, exn, false, fn, fun, 
    functor, handle, if, in, include, 
    infix, infixr, int, let, list, local, 
    nil, nonfix, not, o, of, op, open, 
    option, orelse, overload, print, 
    raise, real, rec, ref, sharing, sig, 
    signature, string, struct, structure, 
    substring, then, true, type, unit, val, 
    vector, where, while, with, withtype, word
  },
  %
  keywordstyle=\ttfamily\color{red},
  %
  commentstyle=\ttfamily\color{gray},
  % Spaces are not displayed as a special character
  showstringspaces=false,
  %
  mathescape=true,
  %
  escapeinside={!}{!}
}
\lstnewenvironment{grm}{\lstset{language=grammar}}{}

%% This makes lstlistings work inside math environment
\usepackage{letltxmacro}
\newcommand*{\SavedLstInline}{}
\LetLtxMacro\SavedLstInline\lstinline
\DeclareRobustCommand*{\lstinline}{%
  \ifmmode
    \let\SavedBGroup\bgroup
    \def\bgroup{%
      \let\bgroup\SavedBGroup
      \hbox\bgroup
    }%
  \fi
  \SavedLstInline
}

\renewcommand{\lstlistingname}{Example}% Listing -> Algorithm
\renewcommand{\lstlistlistingname}{List of \lstlistingname s}% List of Listings -> List of Algorithms

\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommand{\gr}[1]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum]{G: #1}}
\newcommand{\leb}[1]{\todo[linecolor=Green,backgroundcolor=Green!40,bordercolor=Green]{L: #1}}

% Macros for translation
\newcommand\stog{\boldsymbol{\Longrightarrow}}
\newcommand{\stoga}[1]{\overset{#1}{\boldsymbol{\Longrightarrow}}}
\newcommand\stogtycon{\;\stog_\mathtt{TyCon}\;}
\newcommand\stogatexp{\;\stog_\mathtt{AtExp}\;}
\newcommand\stogexp{\;\stog_\mathtt{Exp}\;}
\newcommand\stogmatch{\;\stog_\mathtt{Match}\;}
\newcommand\stogdec{\;\stog_\mathtt{Dec}\;}
\newcommand\stogvalbind{\;\stog_\mathtt{ValBind}\;}
\newcommand\stogtybind{\;\stog_\mathtt{TyBind}\;}
\newcommand\stogdatbind{\;\stog_\mathtt{DatBind}\;}
\newcommand\stogconbind{\;\stog_\mathtt{ConBind}\;}
\newcommand\stogexbind{\;\stog_\mathtt{ExBind}\;}
\newcommand\stogatpat{\;\stog_\mathtt{AtPat}\;}
\newcommand\stogpatrow{\;\stog_\mathtt{PatRow}\;}
\newcommand\stogpat{\;\stog_\mathtt{Pat}\;}
\newcommand\stogty{\;\stog_\mathtt{Ty}\;}
\newcommand\stogtyvar{\;\stog_\mathtt{TyVar}\;}
\newcommand\stoglab{\;\stog_\mathtt{Lab}\;}
\newcommand\stogscon{\;\stog_\mathtt{SCon}\;}
\newcommand\stogvid{\;\stog_\mathtt{VId}\;}

\newcommand\stogstrexp{\;\stog_\mathtt{StrExp}\;}
\newcommand{\stogstrexpa}[1]{\;\stoga{#1}_\mathtt{StrExp}\;}
\newcommand\stogstrdec{\;\stog_\mathtt{StrDec}\;}
\newcommand\stogstrbind{\;\stog_\mathtt{StrBind}\;}

\newcommand\stogsigexp{\;\stog_\mathtt{SigExp}\;}
\newcommand{\stogsigexpa}[1]{\;\stoga{#1}_\mathtt{SigExp}\;}
\newcommand\stogsigdec{\;\stog_\mathtt{SigDec}\;}
\newcommand\stogsigbind{\;\stog_\mathtt{SigBind}\;}

\newcommand\stogspec{\;\stog_\mathtt{Spec}\;}
\newcommand{\stogspeca}[1]{\;\stoga{#1}_\mathtt{Spec}\;}
\newcommand\stogvaldesc{\;\stog_\mathtt{ValDesc}\;}
\newcommand\stogtypdesc{\;\stog_\mathtt{TypDesc}\;}
\newcommand\stogdatdesc{\;\stog_\mathtt{DatDesc}\;}
\newcommand\stogcondesc{\;\stog_\mathtt{ConDesc}\;}
\newcommand\stogexdesc{\;\stog_\mathtt{ExDesc}\;}
\newcommand\stogstrdesc{\;\stog_\mathtt{StrDesc}\;}

\newcommand\stogfundec{\;\stog_\mathtt{FunDec}\;}
\newcommand\stogfunbind{\;\stog_\mathtt{FunBind}\;}
\newcommand\stogtopdec{\;\stog_\mathtt{TopDec}\;}

\newcommand\stogstrid{\;\stog_\mathtt{StrId}\;}
\newcommand\stogfunid{\;\stog_\mathtt{FunId}\;}
\newcommand\stogsigid{\;\stog_\mathtt{SigId}\;}

\newcommand{\tbd}{\colorbox{yellow}{\textbf{TBD}}}

\newcounter{infercount}
\setcounter{infercount}{1}
\newcommand{\infern}[3]{\infer[{\mathsf{#3}}_{\arabic{infercount}}\stepcounter{infercount}]{#2}{#1}}

\newcommand\derived[2]{\smle{#1}&\smle{#2}}

\title{Translation of SML programs into Coq programs}
\date{}

\begin{document}
\maketitle

The goal of this document is to define formally the translation of SML
programs, represented by their abstract syntax tree (AST) into Coq
programs, represented by Gallina's AST. Before defining the
translation, we specify the two ASTs in question.

% Testing environments:
% 
% \begin{sml}
% datatype 'a tree = Empty
%                  | Node of 'a tree * 'a * 'a tree
% \end{sml}
% 
% \begin{coq}
% Definition g y := 
%   match (cons 1 nil) with
%     | (x :: l) => x + y
%     | _ => patternFailure
%   end.
% \end{coq}

\section{HaMLet}

HaMLet~\cite{hamlet} is an SML implementation whose goal is to be an
accurate implementation of the language definition~\cite{smldef}, and
a platform for experimentation. There are two main reasons why we
chose it for this work. First of all, it is faithful to SML's
definition, and all bugs and ``grey areas'' are well documented.
Secondly, it is easy to access various steps of the compilation
process. Particularly, the abstract syntax tree from the elaboration
phase was readily available.

In order to have a translation as precise as possible, we needed a few
modifications in HaMLet. Most changes were related to derived forms.
Derived forms are SML expressions that can be replaced by equivalent
forms during parsing, resulting in SML parse trees that are formed by
only a subset of the constructs in syntax trees. For example, boolean
operators can be replaced by the equivalent \smle{if ... then ... else}:

\begin{center}
\begin{tabular}{rcl}
{\smle|$e_1$ orelse $e_2$|}  & $\Rightarrow$ & {\smle|if $e_1$ then true else $e_2$|} \\
{\smle|$e_1$ andalso $e_2$|} & $\Rightarrow$ & {\smle|if $e_1$ then $e_2$ else false|}
\end{tabular}
\end{center}

HaMLet translates the derived forms as specified in SML's definition.
Translating this subset of SML's syntax to Coq is correct -- semantically
speaking -- however, the resulting Coq code will look very different: an
\smle{orelse} expression will be translated into an \coqe{if...then...else}
expression. Therefore, we decided to keep the original grammatical form and
translate that to Gallina.

Even though the translation is done on the abstract syntax tree with
the derived forms, we still need to make sure that the code type
checks and runs.  Additionally, the elaboration phase provides crucial
information for the translation, such as non-exhaustive match
warnings. These two phases do not consider the derived forms. This
problem is solved by one of two approaches, depending on the
construct: (1) the derived form is replaced by the equivalent form
(using functions from \texttt{parse/DerivedFormsCore.sml}), and we
interpret any needed information in the context of the derived form;
or (2) we implement an extra case for the derived form when it is
straighforward.

Option (2) is much less redundant, but harder to implement, and we now
need to reason about the correctness of the new syntax and semantics
checks (note that even SML's definition does not have elaboration or
evaluation rules for the derived forms because it assumes that they are
equivalent to their equivalent form and it only has rules for the
equivalent forms). So, if SML does not have rules for these forms, how can
we guarantee correctness?? I guess, however, correctness is
straightforward, because we are basically doing the same checks that
we've been doing on equivalent forms but on the derived forms.

\subsection{Changes in HaMLet}

The following tables are taken from SML's documentation but in our case, we
restore the original forms (left column) from their equivalent forms (right
column). The reason we do this step is because (while the semantics does not
change) the code looks very foreign after derivation (and hence does the
translation).

Note that some derivations are not restored because the output doesn't affect
the translation (see discussion on \emph{fvalbind} below). 

\newcommand\changedto{\Longrightarrow}

\noindent
\textbf{Expressions}\\
\begin{tabularx}{1.0\textwidth} { 
  | >{\raggedright\arraybackslash}X
  | >{\raggedright\arraybackslash}X | }
 \hline
 Derived Form & Equivalent Form \\
 \hline
 \derived{()}{\{ \}}\\
 \hline
 \derived{(exp_1, ... , exp_n)}{\{1 = exp_1, ... , n = exp_n\}}\\
 \hline
 \derived{[exp_1, ... , exp_n]}{exp_1 :: ... :: exp_n :: nil}\\
 \hline
 \derived{case exp of match}{(fn match) (exp)}\\
 \hline
 \derived{if exp_1 then exp_2 else exp_3}{case exp_1 of true => exp_2 \ \ \ \ \ \ \ \ \  | false => exp_3}
 \\
 \hline
 \derived{exp_1 andalso exp_2}{if exp_1 then exp_2 else false}\\
 \hline
 \derived{exp_1 orelse exp_2}{if exp_1 then true else exp_2}\\
\hline
\end{tabularx}\\ \\

\noindent
\textbf{Patterns}\\
\begin{tabularx}{1.0\textwidth} { 
  | >{\raggedright\arraybackslash}X
  | >{\raggedright\arraybackslash}X | }
 \hline
 Derived Form & Equivalent Form \\
 \hline
 \derived{()}{\{ \}}\\
 \hline
 \derived{(pat_1, ... , pat_n)}{\{1 = pat_1, ... , n = pat_n\}}\\
 \hline
 \derived{[pat_1, ... , pat_n]}{pat_1 :: ... :: pat_n :: nil}\\
 \hline
\end{tabularx}\\ \\

\noindent
\textbf{Types}\\
\begin{tabularx}{1.0\textwidth} { 
  | >{\raggedright\arraybackslash}X
  | >{\raggedright\arraybackslash}X | }
 \hline
 Derived Form & Equivalent Form \\
 \hline
 \derived{ty_1 * ... * ty_n}{\{1 : ty_1, ..., n : ty_n\}}
\\
 \hline
\end{tabularx}

\subsubsection{Useful Derived Forms}

The derivation of function-value bindings \emph{fvalbind} is the one case where we
need to keep the equivalent form because it simplifies translation. The syntax in
Gallina does not allow for pattern-matching on function arguments, so the
equivalent form (which transforms the function pattern matching into a
case statement) solves the problem.

\noindent
\begin{tabularx}{1.0\textwidth} { 
  | >{\raggedright\arraybackslash}X
  | >{\raggedright\arraybackslash}X | }
 \hline
 Derived Form & Equivalent Form \\
\hline
 &\smle{[op] vid = fn vid_1 => ... => fn vid_n =>}\\
 &\smle{case (vid_1, ..., vid_n) of}\\ 
 \derived
 {[op] vid atpat_11 ... atpat_1n [:ty] = exp_1}
 {(atpat_11, ..., atpat_1n) => exp_1 [:ty]}\\
 \derived
 {| [op] vid atpat_21 ... atpat_2n [:ty] = exp_2}
 {| (atpat_21, ..., atpat_2n) => exp_2 [:ty]} 
  \\ 
 \vdots & \vdots
 \\ 
 \derived
 {| [op] atpat_m1 ... atpat_mn [:ty] = exp_m}
 {| (atpat_m1, ..., atpat_mn) => exp_m [:ty]}
 \\  
 $\langle \texttt{and } fvalbind \rangle$ &
  $\langle \texttt{and } fvalbind \rangle $ \\
 \hline 
\end{tabularx}

\section{Changes in Gallina}

\section{Translation of the Core}
In this section we define the translation from our modified HaMLet AST to our
also modified Gallina's AST. We will use a derivation system with the judgment
$S \stog G$, where $S$ and $G$ are SML and Gallina ASTs respectively. Gallina 
variables are typically denoted by \coqe{x\g}, so that the prime symbol \smle{'}
is reserved for SML's type variables.

Before presenting the derivation system defining the translation
formally, we explain noteworthy points.

\subsection{Overloaded Operators}

Some comparison and arithmetic operators in SML are overloaded for
multiple types. For example, the equality check works for strings and
integers:

\begin{sml}
val b = "a" = "a" andalso 5 = 3;
\end{sml}

Boolean equality checks for string and integers in Coq, denoted by
\coqe{=?} are defined in \coqe{string_scope} and \coqe{Z_scope},
respectively. However, the last opened scope shadows the first, and
trying to use both at the same time fails. For example:

\begin{coq}
Require Import ZArith.
Open Scope Z_scope.
Require Import String.
Open Scope string_scope.
Require Import Bool.

Fail Definition b := ("a" =? "a") && (5 =? 3).
\end{coq}

\noindent
indeed fails with the message:
\texttt{The term "5" has type "Z" while it is expected to have type
"string"}.

Operation overload is solved using typeclasses. We have defined
several typeclasses for different sets of operators and instantiated
them with the types supported. We also defined notations for the
operators to be the same as SML whenever possible. The typeclasses,
instances, and notation definitions can be found in module
\coqe{notationsSML.v}.

\subsection{Records}
\label{sec:records}

A record is a set of named fields typed by record types, for example:

\begin{sml}
{name = "Bob", age = 42} : {name : string, age : int }
\end{sml}

In SML, records can occur as expressions or patterns. When matching a
record pattern, the user can specify the names of relevant fields, and
omit the remaining using ellipsis. For example:

\begin{sml}
fun getAge (r: {name : string, age : int }) = case r of
  {age = x, ...} => x;
\end{sml}

It is important to note that SML must be able to infer what fields are
omitted by the ellipsis, otherwise it terminates with an error.

Gallina has support for record types as well
(\url{https://coq.github.io/doc/master/refman/language/core/records.html}),
however these are not built-in types and must be declared using
\coqe{Record}. So the \smle{getAge} function above could be:

\begin{coq}
Record rec := { name : string; age : Z }.
Definition getAge (r : rec) := match r with 
  {| name := _; age := x |} => x.
\end{coq}

There are three important points that must be taken into consideration
when translating records:

\begin{enumerate}
  \item Any record expression, type, or pattern in an SML declaration
  will possibly require a \coqe{Record} declaration preceding the
  translation, and record types must be replaced by the \coqe{Record}
  identifier.

  \item The \coqe{Record} declaration automatically generates
  projection functions for each of the record's fields, as a result,
  field names cannot be reused in the code.

  \item There is no Gallina equivalent to SML's ellipsis when pattern
  matching records. So the translation must make all record fields
  explicit in patterns.
\end{enumerate}

To make sure all necessary records are declared in the translation, we
make use of a \emph{record context} associated with Gallina's AST.
This context is split into a local and a global part. The global
record context $\mathcal{R}_g$ contains all record types that already
have a declaration in the AST. The local record context
$\mathcal{R}_l$ is used in the translation of SML's declarations, and
starts empty. As the declaration is deconstructed, record expressions,
patterns, or types may be encountered. If the record type is in
$\mathcal{R}_g$ or $\mathcal{R}_l$ the translation proceeds as usual.
If not, the type is stored in $\mathcal{R}_l$ using a fresh
name\footnote{All fresh names start with \_, since names in SML cannot
start with this character.}. Once
the declaration translation is done, the types from $\mathcal{R}_l$
are translated into \coqe{Record} AST's and added to the main
translation AST before the declaration. The content of $\mathcal{R}_l$
is then moved to $\mathcal{R}_g$.

To avoid name clashing, we modify the record fields' names by
prefixing it with the fresh name used for the record type. Each
time a record type, expression, or pattern is found, either its type
is found in the record context, or a new type is created. In both
situations we are able to tell what this prefix is, and rename the
labels accordingly.

Ellipsis on record patterns are resolved by looking into the
annotations after SML's elaboration phase. Since the record type must
be able to be inferred, this information can be extracted after
elaboration, and the pattern can be unfolded with all fields.

\subsection{Type Variables}

In SML the programmer can leave types implicit most of the time, even
when the type is polymorphic. For instance: \smle{val L = []}.
%
In contrast, Coq only allows type variables to be implicit if their
instantiation can be inferred from context. Therefore, the declaration
\coqe{Definition L := []} fails with \texttt{Cannot infer the implicit
parameter A of nil whose type is "Type"}.

As a result, type variables must be made explicit when translating SML
declarations, and this is done using a type variable context
$\mathcal{T}$. As the declaration is traversed, the types of its
expressions can be found in the annotations (after elaboration). The
type variables are collected in $\mathcal{T}$, and they are added as
implicit arguments of the resulting Coq definition. The declaration's
type is also made explicit as it might be polymorphic. 

As an example, the SML declaration \smle{val L = []} is translated as:

\begin{coq}
Definition L {_a} : list {_a} := [].
\end{coq}


\subsection{Typed Patterns}

\subsection{Exceptions}

\subsection{Basis Library}

SML's basis library is included in most of its implementations and
contains some of the more popular datatypes and functions. Since most
SML programs will make use of some part of the basis library, we have
provided a Coq implementation for:
\smle{string},
\smle{real},
\smle{option},
\smle{list},
\smle{int},
\smle{char},
\smle{listPair},
\smle{bool},
\smle{stringCvt}, and
\smle{IEEEReal}.

The documentation of those libraries can be found at\\
\url{https://github.com/meta-logic/sml-to-coq/tree/master/coqBasisLib/doc}

They were renamed by adding the suffix \coqe{Sml}.

Most of the functions could be translated directly, however a few of
them needed special treatment for one of two reasons: (1)
non-termination, and (2) non-structural recursion. 

The (possibly) non-terminating functions are:
\begin{sml}
StringCvt.splitl : (char -> bool) -> (char, 'a) reader -> 'a -> string * 'a
StringCvt.takel  : (char -> bool) -> (char, 'a) reader -> 'a -> string * 'a
StringCvt.dropl  : (char -> bool) -> (char, 'a) reader -> 'a -> string * 'a
StringCvt.skipWS : (char, 'a) reader -> 'a -> 'a
\end{sml}

The non-structurally recursive functions are:
\begin{sml}
Real.toIntl : IEEEReal.rounding_mode -> real -> int
Real.toLargeInt : rounding_mode -> real -> LargeInt.int
Real.floor : real -> int
Real.ceil  : real -> int
Real.trunc : real -> int
Real.round : real -> int
\end{sml}

In both cases the function's signature is changed to accept
one extra parameter: a natural number which is an upper-bound on the
recursion.

\subsection{Translation rules}

The sections below present the derivation rules for the translation of
each syntactic category in SML's AST.

\subsubsection{Record Labels}

Record labels are translated using the record type prefix, as
explained in Section~\ref{sec:records}.

\[
\infer[\mathsf{Lab}]{\smle{pre, l} \stoglab \coqe{pre_l}}{}
\]

\subsubsection{Type Constructors}

Most type constructors are translated \emph{as is}, using the
$\mathsf{TyCon}$ rule.  However, some built-in type constructors need
to be translated to the corresponding types in Coq.

\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{TyCon}]{\smle{tycon} \stogtycon \coqe{tycon}}{
  \smle{tycon} \notin \{ \smle{int},\smle{real},\\
  \smle{char},\smle{order},\smle{unit} \}
}
&
\infer[\mathsf{TyCon}_{\smles{int}}]{\smle{int} \stogtycon \coqe{Z}}{}
\\
\infer[\mathsf{TyCon}_{\smles{real}}]{\smle{real} \stogtycon \coqe{float}}{}
&
\infer[\mathsf{TyCon}_{\smles{char}}]{\smle{char} \stogtycon \coqe{ascii}}{}
\\
\infer[\mathsf{TyCon}_{\smles{order}}]{\smle{order} \stogtycon \coqe{comparison}}{}
&
\infer[\mathsf{TyCon}_{\smles{unit}}]{\smle{unit} \stogtycon \coqe{unit}}{}
\\
\end{array}
\]


\subsubsection{Types}

Type variables in SML are prefixed by \smle{'}, but this is illegal in
Coq. Therefore, we prefix type variables in Coq by \coqe{_}.

\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{c}
\infer[\mathsf{Ty}_{\smles{TyVar}}]{\smle{'t} \stogty \coqe{_t}}{
  \smle{t} \text{ is alphanumeric}
}
\end{array}
\]
\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{Ty}_{()}]{\smle{(t)} \stogty \coqe{(t\\g)}}{
  \smle{t} \stogty \coqe{t\\g}
}
&
\infer[\mathsf{Ty}_{\smles{->}}]{\smle{t_1 -> t_2} \stogty \coqe{t\\g_1 -> t\\g_2}}{
  \smle{t_1} \stogty \coqe{t\\g_1}
  &
  \smle{t_2} \stogty \coqe{t\\g_2}
}
\end{array}
\]
\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{c}
\infer[\mathsf{Ty}_{\smles{TyCon}}]{\smle{t_1, \\dots ,t_n con} \stogty \coqe{con\\g t\\g_1 ... t\\g_n}}{
  \smle{con} \stogtycon \coqe{con\\g}
  &
  \smle{t_i} \stogty \coqe{t\\g_i} 
  & 
  \forall i. 1 \leq i \leq n, n \geq 0
}
\\
\infer[\mathsf{Ty}_{\smles{*}}]{\smle{(t_1 * t_2 * \\dots * t_n)} \stogty 
                                   \coqe{(t\\g_1 * t\\g_2 * ... * t\\g_n)\%type}}
{
  \smle{t_i} \stogty \coqe{t\\g_i} 
  & 
  \forall i. 1 \leq i \leq n, n \geq 1
}
\\
\infer[\mathsf{Ty}_{rec}]{\smle{\{ l_1: t_1, \\dots, l_n: t_n \}} \stogty \coqe!\{ l\\g_1: t\\g_1; ...; l\\g_n: t\\g_n \}!}{
  \smle{pre, l_i} \stoglab \coqe{l\\g_i}
  &
  \smle{t_i} \stogty \coqe{t\\g_i}
  &
  \forall i. 1 \leq i \leq n, n \geq 1
}
\end{array}
\]
\leb{Add record context to the record rule}

Tuples need to be explicitly annotated as a type (\%\coqe{type}) so
that they are not interpreted as \coqe{nat} multiplication. For
example, the following definition fails if the tuple type is not
annotated:

\begin{coq}
Fail Definition t := nat * nat.
\end{coq}

Notice that type constructors may take 0 arguments 
(rule $\mathsf{Ty}_{\smles{TyCon}}$), but tuple and record types 
must consist of at least one type 
(rules $\mathsf{Ty}_{\smles{*}}$ and $\mathsf{Ty}_{rec}$).

\subsubsection{Type Bindings}

Type bindings are translated into Coq definitions. In case they are 
mutually recursive, we need to use \coqe{Fixpoint}, thus the
\coqe{end with} in rule $\mathsf{TyBind}$.

\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{c}
\infer[\mathsf{TyBind}_0]{\smle{'v_1, \\dots ,'v_n con = t} \stogtybind \coqe{con\\g v\\g_1 ... v\\g_n = t\\g}}{
  \smle{con} \stogtycon \coqe{con\\g}
  &
  \smle{t} \stogty \coqe{t\\g}
  &
  \smle{'v_i} \stogty \coqe{v\\g_i} 
  &
  \forall i. 1 \leq i \leq n, n \geq 0
}
\\
\infer[\mathsf{TyBind}]{\smle{b and tb} \stogtybind \coqe{b\\g end with tb\\g}}{
  \smle{b} \stogtybind \coqe{b\\g}
  &
  \smle{tb} \stogtybind \coqe{tb\\g}
}
\end{array}
\]

\subsubsection{Special constants}

Special constants are value inhabitants of \smle{int}, \smle{real}, 
\smle{word}, \smle{string}, and \smle{char}. Note that:

\begin{itemize}
  \item The notation \# for characters in Coq is defined in the 
  library \texttt{charSml.v} to look exactly like SML characters.

  \item Real constants are translated using the explicit type
  annotation \%\coqe{float}. This could be avoided by using 
  \coqe{float_scope}, however opening this scope will make Coq 
  interpret any number without dot notation, such as \coqe{5}, 
  as a floating point number instead of an integer.
  In SML \smle{5} is \emph{always} an integer, and \smle{5.0} is
  a floating point number. In order to keep the original types,
  our solution is \emph{not} to open \coqe{float_scope} and explicit
  annotate every floating point number.

  \item Negative numbers are indicated by $\sim$ in SML and by 
  \coqe{-} in Coq.

\end{itemize}

\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{SCon}_{\smles{int}}]{\smle{n} \stogscon \coqe{n}}{}
&
\infer[\mathsf{SCon}_{\smles{int-}}]{\smle!$\sim$ n! \stogscon \coqe{- n}}{}
\\
\infer[\mathsf{SCon}_{\smles{real}}]{\smle{r} \stogscon \coqe{r\%float}}{}
&
\infer[\mathsf{SCon}_{\smles{real-}}]{\smle!$\sim$ r! \stogscon \coqe{(- r)\%float}}{}
\\
\infer[\mathsf{SCon}_{\smles{string}}]{\smle{s} \stogscon \coqe{s}}{}
&
\infer[\mathsf{SCon}_{\smles{char}}]{\smle{#c} \stogscon \coqe{#c}}{}
\\
\infer[\mathsf{SCon}_{\smles{word}}]{\smle{w} \stogscon \tbd}{}
&
\end{array}
\]


\subsubsection{Value Identifiers}

Most value identifiers are translated \emph{as is} from SML to Coq, 
however there are a few special cases that need to be handled
exceptionally because the corresponding identifier in Coq is
different. This is mostly due to different type constructors or
functions.

\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{VId}]{\smle{id} \stogvid \coqe{id}}{
  \smle{id} \notin \{\smle{SOME}, \smle{NONE},\\
  \smle{LESS}, \smle{EQUAL}, \smle{GREATER} \}
}
&
\infer[\mathsf{VId}_{\smles{EQUAL}}]{\smle{EQUAL} \stogvid \coqe{Eq}}{}
\\
\infer[\mathsf{VId}_{\smles{LESS}}]{\smle{LESS} \stogvid \coqe{Lt}}{}
&
\infer[\mathsf{VId}_{\smles{GREATER}}]{\smle{GREATER} \stogvid \coqe{Gt}}{}
\\
\infer[\mathsf{VId}_{\smles{SOME}}]{\smle{SOME} \stogvid \coqe{Some}}{}
&
\infer[\mathsf{VId}_{\smles{List.exists}}]{\smle{List.exists} \stogvid \coqe{List.existsb}}{}
\\
\infer[\mathsf{VId}_{\smles{NONE}}]{\smle{NONE} \stogvid \coqe{None}}{}
&
\infer[\mathsf{VId}_{\smles{ListPair.exists}}]{\smle{ListPair.exists} \stogvid \coqe{ListPair.existsb}}{}
\end{array}
\]

% A more extensive explanation on why we did not change SML's AST and
% went with the special case instead. Leaving it here for posterity.
%
% \begin{paragraph}{\smle{option} expressions}
% In SML, the type \smle{option}, with constructors \smle{SOME} and \smle{NONE},
% is not built-in. Therefore, the keywords \smle{SOME} and \smle{NONE} are
% \lstinline{VId}s and would be translated as is (by rule $\mathsf{AtExp}_2$).
% This is problematic because Coq's option type constructors are \coqe{Some} and
% \coqe{None} (i.e. in a different capitalization). One way to solve this is to
% add special constructors for option types to SML's AST, much like we did for
% tuples and lists. However, unlike tuples and lists, option types are not
% recognized by the parser as special entities. This means we would need deeper
% changes in HaMLet to create dedicated constructors for options. To avoid these
% more intrusive modifications, we instead use rule $\mathsf{AtExp}_2$ with a
% \emph{side condition}: if \smle{e} is \smle{SOME} or \smle{NONE}, then it is
% translated to \coqe{Some} or \coqe{None}, respectively.
% \end{paragraph}


\subsubsection{Atomic Expressions}
\leb{Need to take special care of expressions with uninstantiated type variables (e.g. NONE)}

\setlength{\jot}{0.5pt} 
\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{AtExp}_{\smles{SCon}}]{\smle{c} \stogatexp \coqe{c\\g}}{
  \smle{c} \stogscon \coqe{c\\g}
}
&
\infer[\mathsf{AtExp}_{\smles{VId}}]{\smle{id} \stogatexp \coqe{id\\g}}{
  \smle{id} \stogvid \coqe{id\\g}
}
\\
\infer[\mathsf{AtExp}_{\smles{()}}]{\smle{()} \stogatexp \coqe{tt}}{}
&
\infer[\mathsf{AtExp}_{\smles{(e)}}]{\smle{(e)} \stogatexp \coqe{(e\\g)}}{
  \smle{e} \stogexp \coqe{e\\g}
}
\end{array}
\]
\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{c}
\infer[\mathsf{AtExp}_{\smles{let}_1}]{\smle{let d in e end} \stogatexp \coqe{let d\\g in e\\g}}{
  \smle{e} \stogexp \coqe{e\\g} & \smle{d}\stogdec \coqe{Definition d\\g}
}
\\
\infer[\mathsf{AtExp}_{\smles{let}_n}]{\smle{let d in e end} \stogatexp \coqe{let d_1 in ... in let d_n in e\\g}}{
  \smle{e} \stogexp \coqe{e\\g}
  &
  \smle{d}\stogdec \coqe{Definition d_1 ... Definition d_n} 
}
\\
\infer[\mathsf{AtExp}_{tpl}]{\smle{(e_1, \\dots ,e_n)} \stogatexp \coqe{(e\\g_1, ...,e\\g_n)}}{
  \smle{e_i} \stogexp \coqe{e\\g_i} 
  & 
  \forall i. 1 \leq i \leq n, n \geq 1
}
\\
\infer[\mathsf{AtExp}_{lst}]{\smle{[e_1, \\dots ,e_n]} \stogatexp \coqe{[e\\g_1; ...;e\\g_n]}}{
  \smle{e_i} \stogexp \coqe{e\\g_i} 
  & 
  \forall i. 1 \leq i \leq n, n \geq 0
}
\\
\infer[\mathsf{AtExp}_{\smles{op}}]{\smle{op id} \stogatexp \tbd}{}
\\
\infer[\mathsf{AtExp}_{rec}]{\smle{\{l_1 = e_1, \\dots, l_n = e_n\}} \stogatexp \coqe!\{| l\\g_1 = e\\g_1; ...; l\\g_n = e\\g_n |\}!}{
  \smle{pre, l_i} \stoglab \coqe{l\\g_i}
  &
  \smle{e_i} \stogexp \coqe{e\\g_i}
  &
  \forall i. 1 \leq i \leq n, n \geq 1
}
\end{array}
\]
\gr{Use record contexts in the record rules.}

The declarations \smle{d} inside SML let-expressions are translated as
``top-level'' Coq declarations (that is why the \coqe{Definition} keyword is
there). The translation \coqe{d\g} or \coqe{d_i} is extracted from this
definition.


\subsubsection{Expressions}
\leb{for the "match" rule, we need to mention here that
non-exhaustive matches have an additional case for pattern failure.}

\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{Exp}_{\smles{AtExp}}]{\smle{e} \stogexp \coqe{e\\g}}{
  \smle{e} \stogatexp \coqe{e\\g}
}
&
\infer[\mathsf{Exp}_{app}]{\smle{e_1 e_2} \stogexp \coqe{e\\g_1 e\\g_2}}{
  \smle{e_1} \stogexp \coqe{e\\g_1}
  &
  \smle{e_2} \stogatexp \coqe{e\\g_2}
}
\\
\infer[\mathsf{Exp}_{ty}]{\smle{e : t} \stogexp \coqe{e\\g : t\\g}}{
  \smle{e} \stogexp \coqe{e\\g}
  &
  \smle{t} \stogty \coqe{t\\g}
}
&
\infer[\mathsf{Exp}_{\smles{fn}}]{\smle{fn m} \stogexp \tbd}{
  \smle{m} \stogmatch \coqe{m\\g}
}
\\
\infer[\mathsf{Exp}_{\smles{handle}}]{\smle{e handle m} \stogexp \tbd}{
  \smle{e} \stogexp \coqe{e\\g}
  &
  \smle{m} \stogmatch \coqe{m\\g}
}
&
\infer[\mathsf{Exp}_{\smles{raise}}]{\smle{raise e} \stogexp \tbd}{
  \smle{e} \stogexp \coqe{e\\g}
}
\end{array}
\]
\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{c}
\infer[\mathsf{Exp}_{\smles{case}}]{\smle{case e of m} \stogexp \coqe{match e\\g with m\\g end}}{
  \smle{e} \stogexp \coqe{e\\g}
  &
  \smle{m} \stogmatch \coqe{m\\g}
}
\\
\infer[\mathsf{Exp}_{\smles{if}}]{\smle{if e_1 then e_2 else e_3} \stogexp 
                                  \coqe{if e\\g_1 then e\\g_2 else e\\g_3}}{
  \smle{e_i} \stogexp \coqe{e\\g_i}
  &
  \forall i \in \{1,2,3\}
}
\end{array}
\]
\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{Exp}_{and}]{\smle{e_1 andalso e_2} \stogexp 
                           \coqe{e\\g_1 \&\& e\\g_2}}{
  \smle{e_1} \stogexp \coqe{e\\g_1}
  &
  \smle{e_2} \stogexp \coqe{e\\g_2}
}
&
\infer[\mathsf{Exp}_{or}]{\smle{e_1 orelse e_2} \stogexp 
                          \coqe{e\\g_1 || e\\g_2}}{
  \smle{e_1} \stogexp \coqe{e\\g_1}
  &
  \smle{e_2} \stogexp \coqe{e\\g_2}
}
\end{array}
\]

\begin{paragraph}{SML booleans}
The translation of \smle{andalso} and \smle{orelse} requires notations defined
in Coq's \coqe{Bool} library.
\end{paragraph}


\subsubsection{Pattern Matching}

\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{c}
\infer[\mathsf{Match}_0]{\smle{p => e} \stogmatch \coqe{p\\g => e\\g}}{
  \smle{p} \stogpat \coqe{p\\g}
  &
  \smle{e} \stogexp \coqe{e\\g}
}
\\
\infer[\mathsf{Match}]{\smle{p => e | M} \stogmatch \coqe{p\\g => e\\g | M\\g}}{
  \smle{p} \stogpat \coqe{p\\g}
  &
  \smle{e} \stogexp \coqe{e\\g}
  &
  \smle{M} \stogmatch \coqe{M\\g}
}

\end{array}
\]

\subsubsection{Atomic Patterns}

\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{AtPat}_{\_}]{\smle{_} \stogatpat \coqe{_}}{}
&
\infer[\mathsf{AtPat}_{\smles{SCon}}]{\smle{c} \stogatpat \coqe{c\\g}}{
  \smle{c} \stogscon \coqe{c\\g}
}
\\
\infer[\mathsf{AtPat}_{\smles{VId}}]{\smle{id} \stogatpat \coqe{id\\g}}{
  \smle{id} \stogvid \coqe{id\\g}
}
&
\infer[\mathsf{AtPat}_{\smles{op}}]{\smle{op id} \stogatpat \tbd}{}
\\
\infer[\mathsf{AtPat}_{\smles{(p)}}]{\smle{(p)} \stogatpat \coqe{(p\\g)}}{
  \smle{p} \stogpat \coqe{p\\g}
}
&
\infer[\mathsf{AtPat}_{\smles{()}}]{\smle{()} \stogatpat \coqe{()}}{}
\end{array}
\]
\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{c}
\infer[\mathsf{AtPat}_{tpl}]{\smle{(p_1, \\dots ,p_n)} \stogatpat \coqe{(p\\g_1, ...,p\\g_n)}}{
  \smle{p_i} \stogpat \coqe{p\\g_i} 
  & 
  \forall i. 1 \leq i \leq n, n \geq 1
}
\\
\infer[\mathsf{AtPat}_{lst}]{\smle{[p_1, \\dots ,p_n]} \stogatpat \coqe{[p\\g_1; ...;p\\g_n]}}{
  \smle{p_i} \stogpat \coqe{p\\g_i} 
  & 
  \forall i. 1 \leq i \leq n, n \geq 0
}
\\
\infer[\mathsf{AtPat}_{rec}]{\smle{\{ p \}} \stogatpat \coqe!\{ p\\g \}!}{
  \smle{p} \stogpatrow \coqe{p\\g}
}
\end{array}
\]

\subsubsection{Record Patterns}

\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{PatRow}_{\dots}]{\smle!$\dots$! \stogpatrow \tbd}{}
&
\infer[\mathsf{PatRow}_0]{\smle{l = p} \stogpatrow \coqe{l\\g = p\\g}}{
  \smle{pre, l} \stoglab \coqe{l\\g}
  &
  \smle{p} \stogpat \coqe{p\\g}
}
\end{array}
\]
\[
\arraycolsep=15pt\def\arraystretch{3}
\begin{array}{c}
\infer[\mathsf{PatRow}]{\smle{lp, pr} \stogpatrow \coqe{lp\\g ; pr\\g}}{
  \smle{lp} \stogpatrow \coqe{lp\\g}
  &
  \smle{pr} \stogpatrow \coqe{pr\\g}
}
\end{array}
\]

\subsubsection{Patterns}

\leb{We allow types in patterns as long as they're not
nested, and we move the type cast to the expression being matched
against.}

\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{Pat}_{\smles{AtPat}}]{\smle{p} \stogpat \coqe{p\\g}}{
  \smle{p} \stogatpat \coqe{p\\g}
}
&
\infer[\mathsf{Pat}_{\smles{Ty}}]{\smle{p : t} \stogpat \tbd}{
  \smle{p} \stogpat \coqe{p\\g}
  &
  \smle{t} \stogty \coqe{t\\g}
}
\\
\infer[\mathsf{Pat}_{\smles{VId}}]{\smle{id p} \stogpat \coqe{id\\g p\\g}}{
  \smle{id} \stogvid \coqe{id\\g}
  &
  \smle{p} \stogatpat \coqe{p\\g}
}
&
\infer[\mathsf{Pat}_{\smles{opVId}}]{\smle{op id p} \stogpat \tbd}{
  \smle{id} \stogvid \coqe{id\\g}
  &
  \smle{p} \stogatpat \coqe{p\\g}
}
\\
\infer[\mathsf{Pat}_{\smles{as}}]{\smle{id as p} \stogpat \coqe{p\\g as id\\g}}{
  \smle{id} \stogvid \coqe{id\\g}
  &
  \smle{p} \stogatpat \coqe{p\\g}
}
&
\infer[\mathsf{Pat}_{\smles{op/as}}]{\smle{op id as p} \stogpat \tbd}{
  \smle{id} \stogvid \coqe{id\\g}
  &
  \smle{p} \stogatpat \coqe{p\\g}
}
\end{array}
\]
\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{c}
\infer[\mathsf{Pat}_{\smles{as/ty}}]{\smle{id : t as p} \stogpat \tbd}{
  \smle{id} \stogvid \coqe{id\\g}
  &
  \smle{t} \stogty \coqe{t\\g}
  &
  \smle{p} \stogatpat \coqe{p\\g}
}
\\
\infer[\mathsf{Pat}_{\smles{op/as/ty}}]{\smle{op id : t as p} \stogpat \tbd}{
  \smle{id} \stogvid \coqe{id\\g}
  &
  \smle{t} \stogty \coqe{t\\g}
  &
  \smle{p} \stogatpat \coqe{p\\g}
}
\end{array}
\]

\subsubsection{Declarations}

TODO

FYI: Record contexts are processed and cleared in rules 
$\mathsf{Dec}_{\smles{val}}$,
$\mathsf{Dec}_{\smles{type}}$,
$\mathsf{Dec}_{\smles{datatype}_1}$, and
$\mathsf{Dec}_{\smles{datatype}_2}$.

\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{Dec}_{\smles{val}}]{\smle{val 'v_1 \\dots 'v_n vb} \stogdec \tbd}{
  \smle{'v_i} \stogty \coqe{v\\g_i}
  &
  \smle{vb} \stogvalbind \tbd
}
&
\infer[\mathsf{Dec}_{\smles{type}}]{\smle{type tb} \stogdec \tbd}{
  \smle{tb} \stogtybind \tbd
}
\\
\infer[\mathsf{Dec}_{\varepsilon}]{\varepsilon \stogdec \tbd}{
}
&
\infer[\mathsf{Dec}_{\smles{;}}]{\smle{d_1 ; d_2} \stogdec \tbd}{
  \smle{d_1} \stogdec \tbd
  &
  \smle{d_2} \stogdec \tbd
}
\end{array}
\]
\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{c}
\infer[\mathsf{Dec}_{\smles{datatype}_1}]{\smle{datatype db} \stogdec \tbd}{
  \smle{db} \stogdatbind \tbd
}
\\
\infer[\mathsf{Dec}_{\smles{datatype}_2}]{\smle{datatype t_1 = datatype t_2} \stogdec \tbd}{
  \smle{t_1} \stogtycon \coqe{t\\g_1}
  &
  \smle{t_2} \stogtycon \coqe{t\\g_2}
}
\\
\infer[\mathsf{Dec}_{\smles{abstype}}]{\smle{abstype db with d end} \stogdec \tbd}{
  \smle{db} \stogdatbind \tbd
  &
  \smle{d} \stogdec \tbd
}
\\
\infer[\mathsf{Dec}_{\smles{exception}}]{\smle{exception eb} \stogdec \tbd}{
}
\\
\infer[\mathsf{Dec}_{\smle{local}}]{\smle{local d_1 in d_2 end} \stogdec \tbd}{
  \smle{d_1} \stogdec \tbd
  &
  \smle{d_2} \stogdec \tbd
}
\\
\infer[\mathsf{Dec}_{\smles{open}}]{\smle{open s_1 \\dots s_n} \stogdec \tbd}{
}
\end{array}
\]

\subsubsection{Value Bindings}

TODO

\subsubsection{Data Bindings}

TODO

\subsubsection{Constructor Bindings}

TODO

\subsubsection{Exception Bindings}

TODO
\newpage

\section{Translation of Modules}

\subsection{In-binding vs. Inline Expressions}

Structure and signature expressions in SML can either be found in a binding or
inline. 

\paragraph{Structure Expressions}

In-binding structure expressions in SML have one format:

\begin{sml}
strid  = strexp
\end{sml}

\noindent
and inline expressions have one format:

\begin{sml}
strid = funid(strexp)
\end{sml}

\noindent
Note that \smle{strexp} stands for a complete structure declaration,
and not only an identifier.


\paragraph{Signature Expressions}

In-binding signature expressions in SML have one format:

\begin{sml}
sigid  = sigexp
\end{sml}

\noindent
while inline signature expressions can appear in five different formats:

\begin{sml}
strexp : sigexp
strexp :> sigexp
include sigexp
structure strid : sigexp
functor funid (strid : sigexp) = strexp
\end{sml}


In Gallina, inline modules and module types are not allowed; they must
be replaced by identifiers:

\begin{coq}
Fail Module D := Dict(ListOrdered(IntOrdered)).
The command has indeed failed with message:
A module cannot be applied to another module application or with-expression; 
you must give a name to the intermediate result module first.
\end{coq}

Therefore, we distinguish between the translation of in-binding
expressions (sections \tbd) and inline expressions (sections \tbd) -
where inbinding expressions are interleaved with the translation rules
of bindings.

Moreover, for inline expressions we use the translation judgement:
\smle{exp} $\stoga{\Sigma}$ \coqe{exp\g} which states that SML's
expression \smle{exp} translates to Gallina's expression \coqe{exp\g}
while producing a -- possibly empty -- set of Gallina sentences
(either module or module type sentences to be precise) that need to
precede the current sentence. Note that the normal transition
judgement $\stog$ is equivalent to $\stoga{\Sigma}$ with $\Sigma$
being empty.

\subsection{Translation rules}

\subsubsection{Structure Expressions (Inline)}
\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{StrExp}_{\smles{id}}]{\smle{StrId} \stogstrexp \coqe{StrId\\g}}{
  \smle{StrId} \stogstrid \coqe{StrId\\g}
}\\
\infer[\mathsf{StrExp}_{\smles{others}}]{\smle{StrExp} \stogstrexpa{\coqe{Sent\\g}} \coqe{StrId\\g}}{
  \smle{StrId = StrExp} \stogstrbind \coqe{Sent\\g}&
  \smle{StrId} \stogstrid \coqe{StrId\\g}&
  \smle{StrId} \notin Context
}
\end{array}
\]
\subsubsection{Structure Declarations}
\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{StrDec}_{\smles{dec}}]{\smle{Dec} \stogstrdec \coqe{Sent\\g}}{
  \smle{Dec} \stogdec \coqe{Sent\\g}
}\\
\infer[\mathsf{StrDec}_{\smles{structure}}]{\smle{structure SBind} \stogstrdec \coqe{Sent\\g}}{
  \smle{SBind} \stogstrbind \coqe{Sent\\g}
}\\
\infer[\mathsf{StrDec}_{\smles{local}}]{\smle{local SDec1 in SDec2 end} \stogstrdec \tbd}{
  \tbd
}\\
\infer[\mathsf{StrDec}_{\smles{sequence}}]{\smle{SDec1; SDec2} \stogstrdec \coqe{SDec1\\g SDec2\\g}}{
  \smle{SDec1} \stogstrdec \coqe{SDec1\\g}&
  \smle{SDec2} \stogstrdec \coqe{SDec2\\g}
}
\end{array}
\]
\subsubsection{Structure Bindings}
\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{StrBind}_{\smles{struct}}]{\smle{S = struct SDec end} \stogstrbind \coqe{Module S. SDec\\g End S.}}{
  \smle{SDec} \stogstrdec \coqe{SDec\\g}
}\\
\infer[\mathsf{StrBind}_{\smles{id}}]{\smle{S = SId} \stogstrbind \coqe{Module S := SId\\g}}{
  \smle{SId} \stogstrid \coqe{SId\\g}
}\\
\infer[\mathsf{StrBind}_{\smles{colon1}}]{\smle{S = SExp : SIG} \stogstrbind \coqe{\\Sigma. Module S\\g <: SIG\\g := SExp\\g}}{
  \smle{S = SExp} \stogstrbind \coqe{Module S\\g := SExp\\g}&
  \smle{SIG} \stogsigexpa{\Sigma} \coqe{SIG\\g}
}\\
\infer[\mathsf{StrBind}_{\smles{colon2}}]{\smle{S = SExp : SIG} \stogstrbind \coqe{\\Sigma. Module S\\g <: SIG\\g. SExp\\g. End S\\g.}}{
  \smle{S = SExp} \stogstrbind \coqe{Module S\\g. SExp\\g. End S\\g.}&
  \smle{SIG} \stogsigexpa{\Sigma} \coqe{SIG\\g}
}\\
\infer[\mathsf{StrBind}_{\smles{seal1}}]{\smle{S = SExp :> SIG} \stogstrbind \coqe{\\Sigma. Module S\\g : SIG\\g := SExp\\g}}{
  \smle{S = SExp} \stogstrbind \coqe{Module S\\g := SExp\\g}&
  \smle{SIG} \stogsigexpa{\Sigma} \coqe{SIG\\g}
}\\
\infer[\mathsf{StrBind}_{\smles{seal2}}]{\smle{S = SExp :> SIG} \stogstrbind \coqe{\\Sigma. Module S\\g : SIG\\g. SExp\\g. End S\\g.}}{
  \smle{S = SExp} \stogstrbind \coqe{Module S\\g. SExp\\g. End S\\g.}&
  \smle{SIG} \stogsigexpa{\Sigma} \coqe{SIG\\g}
}\\
\infer[\mathsf{StrBind}_{\smles{app}}]{\smle{S = FId(SExp)} \stogstrbind \coqe{\\Sigma . Module S := FId\\g(SExp\\g)}}{
  \smle{FId} \stogfunid \coqe{FId\\g}&
  \smle{SExp} \stogstrexpa{\Sigma} \coqe{SExp\\g}
}\\
\infer[\mathsf{StrBind}_{\smles{let}}]{\smle{let SDec in SExp end} \stogstrbind \tbd}{\tbd}
\end{array}
\]
\subsubsection{Signature Expressions (Inline)}
\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{SigExp}_{\smles{id}}]{\smle{SigId} \stogsigexp \coqe{SigId\\g}}{
  \smle{SigId} \stogsigid \coqe{SigId\\g}
}\\
\infer[\mathsf{SigExp}_{\smles{sig}}]{\smle{sig Spec end} \stogsigexpa{\coqe{Sent\\g}} \coqe{SigId\\g}}{\begin{gathered}
  \smle{SigId = sig Spec end} \stogsigbind \coqe{Sent\\g}\\
  \smle{SigId} \stogsigid \coqe{SigId\\g}\quad
  \smle{SigId} \notin Context \end{gathered}
}\\
\infer[\mathsf{SigExp}_{\smles{where1}}]{\smle{SExp where type t = ty} \stogsigexpa{\Sigma} \coqe{SigId\\g with Definition t\\g := ty\\g}}{
  \smle{SExp} \stogsigexpa{\Sigma} \coqe{SigId\\g}&
  \smle{t} \stogtycon \coqe{t\\g}&
  \smle{ty} \stogty \coqe{ty\\g}  
}\\
\infer[\mathsf{SigExp}_{\smles{where2}}]{\begin{gathered}\smle{SExp where type tyvars t = ty} \stogsigexpa{\Sigma} \\ \coqe{SigId\\g with Definition t\\g := fun tyvars\\g => ty\\g}\end{gathered}}{
\begin{gathered}
  \smle{SExp} \stogsigexpa{\Sigma} \coqe{SigId\\g}\\
  \smle{t} \stogtycon \coqe{t\\g}\quad
  \smle{ty} \stogty \coqe{ty\\g}\quad
  \smle{tyvars} \stogtyvar \coqe{tyvars\\g}
  \end{gathered}
}
\end{array}
\]
\subsubsection{Signature Declarations}
\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{SigDec}_{\smles{signature}}]{\smle{signature SBind} \stogsigdec \coqe{Sent\\g}}{
  \smle{SBind} \stogsigbind \coqe{Sent\\g}
}
\end{array}
\]
\subsubsection{Signature Bindings}
\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{SigBind}_{\smles{sig}}]
{\smle{S = sig Spec end} \stogsigbind \coqe{\\Sigma. Module Type S. Spec\\g End S.}}
{
  \smle{Spec} \stogspeca{\Sigma} \coqe{Spec\\g}
}\\
\infer[\mathsf{SigBind}_{\smles{id}}]
{\smle{S = SId} \stogsigbind \coqe{Module Type S := SId\\g}}
{
  \smle{SId} \stogsigid \coqe{SId\\g}
}\\
\infer[\mathsf{SigBind}_{\smles{where1}}]
{\begin{gathered} \smle{S = SExp where type t = ty} 
\stogsigbind \\ \coqe{Module Type S\\g := SExp\\g with Definition t\\g := ty\\g.}\end{gathered}
}
{\smle{S = SExp} \stogsigbind \coqe{Module Type S\\g := SExp\\g}&
  \smle{t} \stogtycon \coqe{t\\g}&
  \smle{ty} \stogty \coqe{ty\\g}
}\\ \\
\infer[\mathsf{SigBind}_{\smles{where2}}]
{\begin{gathered} \smle{S = SExp where type tyvars t = ty} 
\stogsigbind \\ \coqe{Module Type S\\g := SExp\\g with Definition t\\g := fun tyvars\\g => ty\\g.}\end{gathered}
}
{\begin{gathered}\smle{S = SExp} \stogsigbind \coqe{Module Type S\\g := SExp\\g}\\
  \smle{t} \stogtycon \coqe{t\\g}\quad
  \smle{ty} \stogty \coqe{ty\\g}\quad
  \smle{tyvars} \stogtyvar \coqe{tyvars\\g}\end{gathered}
}\\ \\
\infer[\mathsf{SigBind}_{\smles{where3}}]
{\begin{gathered} \smle{S = SExp where type t = ty} 
\stogsigbind \\ \coqe{Module Type S\\g. SExp1\\g. Definition t\\g := ty\\g. SExp2\\g. End S\\g.}\end{gathered}
}
{\begin{gathered}\smle{S = SExp} \stogsigbind \\ \coqe{Module Type S\\g. SExp1\\g. Parameter t\\g : Type. SExp2\\g. End S\\g.}\\
  \smle{t} \stogtycon \coqe{t\\g}\quad
  \smle{ty} \stogty \coqe{ty\\g}
\end{gathered}}\\ \\
\infer[\mathsf{SigBind}_{\smles{where4}}]
{\begin{gathered} \smle{S = SExp where type tyvars t = ty} 
\stogsigbind \\ \coqe{Module Type S\\g. SExp1\\g. Definition t\\g tyvars\\g := ty\\g. SExp2\\g. End S\\g.}\end{gathered}
}
{\begin{gathered}\smle{S = SExp} \stogsigbind \\ \coqe{Module Type S\\g. SExp1\\g. Parameter t\\g : Type (-> Type)^n. SExp2\\g. End S\\g.}\\
  \smle{t} \stogtycon \coqe{t\\g}\quad
  \smle{ty} \stogty \coqe{ty\\g}\quad
  \smle{tyvars} \stogtyvar \coqe{tyvars\\g}  \end{gathered}}
\end{array}
\]
\subsubsection{Specification}
\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{Spec}_{\smles{val}}]{\smle{val VDesc} \stogspec \coqe{VDesc\\g}}{
  \smle{VDesc} \stogvaldesc \coqe{VDesc\\g}
}\\
\infer[\mathsf{Spec}_{\smles{type}}]{\smle{type TDesc} \stogspec \coqe{TDesc\\g}}{
  \smle{TDesc} \stogtypdesc \coqe{TDesc\\g}
}\\
\infer[\mathsf{Spec}_{\smles{eqtype}}]{\smle{eqtype TDesc} \stogspec \tbd}{
  \tbd
}\\
\infer[\mathsf{Spec}_{\smles{datatype}}]{\smle{datatype DDesc} \stogspec \coqe{DDesc\\g}}{
  \smle{DDesc} \stogdatdesc \coqe{DDesc\\g}
}\\
\infer[\mathsf{Spec}_{\smles{replication}}]{\smle{datatype d = datatype t} \stogspec \tbd}{
  \tbd
}\\
\infer[\mathsf{Spec}_{\smles{exception}}]{\smle{exception EDesc} \stogspec \coqe{EDesc\\g}}{
  \smle{EDesc} \stogexdesc \coqe{EDesc\\g}
}\\
\infer[\mathsf{Spec}_{\smles{structure}}]{\smle{structure SDesc} \stogspec \coqe{SDesc\\g}}{
  \smle{SDesc} \stogstrdesc \coqe{SDesc\\g}
}\\
\infer[\mathsf{Spec}_{\smles{include}}]{\smle{include SExp} \stogspeca{\Sigma} \coqe{Include SId\\g}}{
  \smle{SExp} \stogsigexpa{\Sigma} \coqe{SId\\g}
}\\
\infer[\mathsf{Spec}_{\smles{sequence}}]{\smle{Spec1; Spec2} \stogspec \coqe{Spec1\\g. Spec2\\g}}{
  \smle{Spec1} \stogspec \coqe{Spec1\\g}&  
  \smle{Spec2} \stogspec \coqe{Spec2\\g}
}\\
\infer[\mathsf{Spec}_{\smles{sharing}}]{\smle{spec sharing type t = t'} \stogspec \tbd}{\tbd
}
\end{array}
\]
\subsubsection{Value Descriptions}
\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{ValDesc}_{\smles{ValDesc0}}]{\smle{val vid : ty} \stogvaldesc \coqe{Parameter vid\\g : ty\\g}}{
  \smle{vid} \stogvid \coqe{vid\\g}&
  \smle{ty} \stogty \coqe{ty\\g}
}\\
\infer[\mathsf{ValDesc}_{\smles{ValDesc1}}]{\smle{VDesc1 and VDesc2} \stogvaldesc \coqe{VDesc1\\g. VDesc2\\g}}{
  \smle{VDesc1} \stogvaldesc \coqe{VDesc1\\g}&
  \smle{VDesc2} \stogvaldesc \coqe{VDesc2\\g}
}
\end{array}
\]
\subsubsection{Type Descriptions}
\[
\arraycolsep=10pt\def\arraystretch{3}
\begin{array}{cc}
\infer[\mathsf{TypDesc}_{\smles{TypDesc0}}]{\smle{tycon} \stogtypdesc \coqe{Parameter tycon\\g : Type}}{
  \smle{tycon} \stogtycon \coqe{tycon\\g}&
}\\
\infer[\mathsf{TypDesc}_{\smles{TypDesc1}}]{\smle{tyvars tycon} \stogtypdesc \coqe{Parameter tycon\\g : Type (-> Type)^n}}{
  \smle{tycon} \stogtycon \coqe{tycon\\g}&
  n = | tyvars |}\\
\infer[\mathsf{TypDesc}_{\smles{TypDesc2}}]{\smle{TDesc1 and TDesc2} \stogtypdesc \coqe{TDesc1\\g. TDesc1\\g.}}{
  \smle{TDesc1} \stogvaldesc \coqe{TDesc1\\g}&
  \smle{TDesc2} \stogvaldesc \coqe{TDesc2\\g}}
\\
\end{array}
\]
\subsubsection{Datatype Descriptions}

\subsubsection{Exception Descriptions}

\subsubsection{Structure Descriptions}

\subsubsection{Functor Declarations}

\subsubsection{Functor Bindings}

\subsubsection{Top-Level Declarations}

\newpage
\section{Generation of induction principle for datatypes}

In SML, datatype constructors that take in more than one argument take
those arguments in uncurried form. Thus such constructors take a tuple
of their arguments and this property is preserved by the translation
to Gallina.
    
As an example we take the following datatype declaration in SML: 

\begin{sml}
datatype 'a tree = Empty
        | Leaf of 'a
        | Node of 'a tree * 'a * 'a tree 
\end{sml}

This datatype defines a tree that is parameterized by an abstract
datatype $'a$. The corresponding translation to Gallina is:

\begin{coq}
    Inductive tree  {_a : Type}  : Type := 
      | Empty 
      | Leaf : _a -> @tree _a
      | Node : (@tree _a * _a * @tree _a)%type -> @tree _a.
\end{coq} 

Here, we note that the Node constructor's input is a tuple type. Upon
defining this datatype, Coq automatically generates an induction
principle where the clause for the Node case is

\begin{coq}
    (forall p, P (Node (p)))
\end{coq}

\noindent
where $P$ is the proposition to be proved by induction. We note here
that this clause does not provide us with any induction hypotheses
that pertain to the two structurally smaller trees that are contained
within the tuple $p$.

Therefore, our translation to Gallina also defines a stronger
induction principle for each datatype declaration that unwraps the
terms within the tuple type, providing the user with the appropriate
induction hypotheses to allow them to use induction to prove theorems
about these datatypes.

In the example above, the appropriate induction principle that be
associated with the given type should be:

\begin{coq}
    Theorem treeIndPrincip: forall  (_a : Type) (P:@tree _a -> Prop), 
      P Empty -> 
      (forall p1, P (Leaf (p1))) -> 
      (forall p1 p2 p3, P p1 -> P p3 -> P (Node (p1, p2, p3))) -> 
      forall tree_obj, P tree_obj.
\end{coq}

\noindent
where the clause corresponding to the Node constructor provides us
with the additional assumptions P (p1) and P (p3) which are the
induction hypotheses for the two subtrees.

In order for the SML-to-Coq translation to provide the stronger
induction principle as well as prove its correctness, we generate a
proof object whose type is that of the stronger induction principle.
For the given example, the corresponding proof object would be as
follows:

\begin{coq}
Fixpoint tree_ind_princip_proof  
  (_a : Type) 
  (P: @tree _a -> Prop) 
  (Hyp_Empty: P Empty)
  (Hyp_Leaf: (forall p1, P (Leaf (p1)))) 
  (Hyp_Node:(forall p1 p2 p3, P p1 -> P p3 -> P (Node (p1, p2, p3)))) 
  (tree_obj:@tree _a)  : P tree_obj := 
  
  match tree_obj with
  | Empty => Hyp_Empty  
  | (Leaf (p1)) => Hyp_Leaf p1  
  | (Node (p1, p2, p3)) => Hyp_Node p1 p2 p3 
            (tree_ind_princip_proof _a P Hyp_Empty Hyp_Leaf Hyp_Node p1)
            (tree_ind_princip_proof _a P Hyp_Empty Hyp_Leaf Hyp_Node p3)
  end.
\end{coq}

The proof object can then be used in place of the default induction
principle to prove theorems concerning the datatype.

%  \section{Simulation}
%  
%  \gr{This is *very* preliminary. Just some ideas to see where it goes.}
%  
%  Let $\rightsquigarrow_s$ and $\rightsquigarrow_g$ denote the evaluation
%  semantics of SML and Gallina, respectively. Then a simulation theorem would look
%  like this:
%  
%  \begin{theorem}
%  Let $S$ be an SML expression(?) such that $S \stog G$, and 
%  $S \rightsquigarrow_s S'$. Then, there exists $G'$ such that
%  $S' \stog G'$ and $G \rightsquigarrow_g G'$.
%  \end{theorem}
%  
%  Relation $\rightsquigarrow_g$ is probably the conversion rules of calculus of
%  constructions, defined at
%  \url{https://coq.inria.fr/refman/language/cic.html#conversion-rules}.
%  
%  Relation $\rightsquigarrow_s$ is probably SML's dynamic semantics, defined in
%  section 6.7 (page 60) in \url{https://smlfamily.github.io/sml97-defn.pdf}.

\appendix

\section{SML's abstract syntax tree}

The datatypes used for SML's abstract syntax tree is defined in the file
\texttt{hamlet/syntax/SyntaxCoreFn.sml}. It is reproduced here in a grammar
format, where the same datatype names are used, and SML keywords are explicit.

Elements in $\langle\rangle$ are optional.

% Constructors ending in X are our additions
\begin{grm}
/* Special Constants */
SCon ::= /* integer, real, word, strings, 
            and character constants (e.g. 42) */

/* Type Constructors */
TyCon ::= /* allowed type constructors (int,tree,list,etc) */

/* Names and identifiers */
VId   ::= /* allowed value identifiers */
StrId ::= /* allowed structure identifiers */
Lab   ::= /* allowed record labels */
TyVar ::= /* allowed type variable names */

/* Type Expressions */
Ty ::= TyVar
     | { Lab : Ty, Lab : Ty, ..., Lab : Ty }
     | !$\langle$!Ty!$\rangle^*$! TyCon /* e.g. 'a, 'b Tree */
     | Ty -> Ty
     | (Ty)
     /* Added types */
     | (Ty * Ty * ... * Ty)

/* Atomic Expressions */
AtExp ::= SCon 
        | !$\langle$!op!$\rangle$! VId 
        | {Lab = Exp, Lab = Exp, ..., Lab = Exp} 
        | let Dec in Exp end 
        | (Exp) 
        /* Added expressions (records in hamlet) */
        | () 
        | (Exp, Exp, ..., Exp) 
        | [Exp, Exp, ..., Exp]

/* Expressions */
Exp ::= AtExp 
      | Exp AtExp 
      | Exp : Ty 
      | Exp handle Match
      | raise Exp 
      | fn Match
      /* Added expressions (derived forms) */
      | case Exp of Match 
      | if Exp then Exp else Exp
      | Exp andalso Exp 
      | Exp orelse Exp

/* Pattern matching */
Match ::= Pat => Exp !$\langle$!| Match!$\rangle$!

/* Atomic Patterns */
AtPat ::= _ 
        | SCon
        | !$\langle$!op!$\rangle$! VId 
        | { !$\langle$!PatRow!$\rangle$! }
        | ( Pat )
        /* Added patterns (translated to records originally) */
        | ()
        | (Pat, Pat, ...)
        | [Pat, Pat, ...]

/* Record Patterns */
PatRow ::= ... /* Wildcard for records */
         | Lab = Pat !$\langle$!, PatRow!$\rangle$!

/* Patterns */
Pat ::= AtPat
      | !$\langle$!op!$\rangle$! VId AtPat
      | Pat : Ty
      | !$\langle$!op!$\rangle$! VId !$\langle$!: Ty!$\rangle$! as pat

/* Declarations */
Dec ::= val !$\langle$!TyVar!$\rangle^*$! ValBind /* E.g. val 'a x = 5 */
      | type TypBind
      | datatype DatBind
      | datatype TyCon = datatype TyCon
      | abstype Datbind with Dec end
      | exception ExBind
      | local Dec in Dec end
      | open StrId ... StrId
      | !$\varepsilon$!
      | Dec ; Dec
      
/* Value binding */
ValBind ::= Pat = Exp !$\langle$!and ValBind!$\rangle$!
          | rec ValBind

/* Type binding */
TypBind ::= !$\langle$!TyVar!$\rangle^*$!  TyCon = Ty !$\langle$!and TypBind!$\rangle$!

/* Data binding */
DatBind ::= !$\langle$!TyVar!$\rangle^*$!  TyCon = ConBind !$\langle$!and DatBind!$\rangle$!

/* Constructor binding */
ConBind ::= !$\langle$!op!$\rangle$! VId !$\langle$!of Ty!$\rangle$! !$\langle$!| ConBind!$\rangle$!

/* Exception binding */
ExBind ::= !$\langle$!op!$\rangle$! VId !$\langle$!of Ty!$\rangle$! !$\langle$!and ExBind!$\rangle$!
         | !$\langle$!op!$\rangle$! VId = !$\langle$!VId!$\rangle$! !$\langle$!and ExBind!$\rangle$!
\end{grm}

\section{Gallina's abstract syntax tree}

This AST is slightly different from Gallina's grammar in Coq's reference manual
(see section ....).

An expression enclosed in square brackets [...] means at
most one occurrence of this expression (this corresponds to an optional
component). The notation "entry sep ... sep entry" stands for a non empty sequence
of expressions parsed by entry and separated by the literal "sep". Similarly,
the notation "entry ... entry" stands for a non empty sequence of expressions
parsed by the "entry" entry, without any separator between.


\begin{grm}


/* Identifiers */
ident ::= string

/* Terms */
term ::= forall binder ... binder , term
       | fun binder ... binder => term
       | fix fix_bodies
       | cofix cofix_bodies
       | let ident [binder ... binder] [: term] := term in term
       | let fix fix_body in term
       | let cofix cofix_body in term
       | let ( name , ... , name ) := term in term
       | let ' pattern [in term] := term in term
       | if term then term else term
       | term : term
       | term -> term
       | term arg ... arg   
       | @ ident [term ... term]
       | term % ident      
       | match match_iterm , ... , match_iterm with
               [ equation | ... | equation ] end    
       | ident
       | sort
       | num
       | _
       | ( term )
       | word
       | real
       | string
       | char
       | hex
       | ( term , ... , term )
       | term * ... * term
       | [ term , ... , term ] /* syntactic square brackets */
       
       
arg ::= term
      | ( ident := term )

binder ::= ( name [: term] ) 
         | ( name ... name [: term] := term ) /* probably can be omitted */
         | ' pattern

name ::= ident | _

sort ::= Prop | Set | Type

fix_bodies ::= fix_body with ... with fix_body for ident

cofix_bodies ::= cofix_body with ... with cofix_body for ident

fix_body ::= ident [binder ... binder] [annotation] [: term] := term

cofix_body ::= ident [binder ... binder] [: term] := term

annotation ::= { struct ident }

match_item ::= term 

dep_ret_type ::= [as name] return_type /* not used */

return_type ::= return term /* not used */

equation ::= pattern => term

pattern ::= ident pattern ... pattern
          | @ ident pattern ... pattern
          | pattern as ident
          | pattern % ident
          | qualid
          | _ 
          | num
          | ( pattern , ... , pattern )
          | [ pattern ; ... ; pattern ] /* syntactic square brackes */ 
          | ( pattern ) /* only present in intermediate translation steps */
			
				
/* The Vernacular */
sentence ::= definition
           | inductive
           | fixpoint
           | sentence ... sentence
           /* Gallina syntax extensions */
           | Record [ recBody , ... , recBody ]
					  	   
definition ::= [Local] Definition ident [binder ... binder] [: term] := term .		   
             | Let ident [binder ... binder] [: term] := term .

inductive ::= Inductive ind_body with ... with ind_body .
            | CoInductive ind_body with ... with ind_body .
			  
ind_body ::= ident  [binder ... binder] : term := clause | ... | clause

clause ::= ident [binder ... binder] [:term]
				
						  
fixpoint ::= Fixpoint fix_body with ... with fix_body .
           | CoFixpoint cofix_body with ... with cofix_body .
\end{grm}

\bibliography{references}{}
\bibliographystyle{abbrv}

\end{document}
